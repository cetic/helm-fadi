adminer:
  affinity: {}
  config:
    design: pepa-linha
    externalserver: ""
    plugins: ""
  enabled: true
  fullnameOverride: ""
  global: {}
  image:
    pullPolicy: IfNotPresent
    pullSecrets: []
    repository: adminer
    tag: 4.8.1-standalone
  ingress:
    annotations: {}
    enabled: false
    hosts: []
    path: /
    tls: []
  nameOverride: ""
  nodeSelector: {}
  replicaCount: 1
  resources: {}
  service:
    annotations: {}
    port: 80
    type: ClusterIP
  tolerations: []
airflow:
  auth:
    existingSecret: ""
    fernetKey: _WJG5F2fIZ6q5LH03MQE45stfYpuLpeqzYcqOIxvCbs=
    forcePassword: false
    password: password1
    secretKey: ""
    username: admin
  clusterDomain: cluster.local
  common:
    exampleValue: common-chart
    global:
      imagePullSecrets: []
      imageRegistry: ""
      storageClass: ""
  commonAnnotations: {}
  commonLabels: {}
  configuration: ""
  dags:
    existingConfigmap: ""
    image:
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/bitnami-shell
      tag: 11-debian-11-r13
  diagnosticMode:
    args:
    - infinity
    command:
    - sleep
    enabled: false
  enabled: false
  executor: CeleryExecutor
  existingConfigmap: ""
  externalDatabase:
    database: postgres
    existingSecret: ""
    existingSecretPasswordKey: ""
    host: fadi-postgresql
    password: password1
    port: 5432
    user: admin
  externalRedis:
    existingSecret: ""
    existingSecretPasswordKey: ""
    host: localhost
    password: ""
    port: 6379
    username: ""
  extraDeploy: []
  extraEnvVars: []
  extraEnvVarsCM: ""
  extraEnvVarsSecret: ""
  extraEnvVarsSecrets: []
  extraVolumeMounts: []
  extraVolumes: []
  fullnameOverride: ""
  git:
    clone:
      args: []
      command: []
      extraEnvVars: []
      extraEnvVarsCM: ""
      extraEnvVarsSecret: ""
      extraVolumeMounts: []
      resources: {}
    dags:
      enabled: false
      repositories:
      - branch: ""
        name: ""
        path: ""
        repository: ""
    image:
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/git
      tag: 2.37.0-debian-11-r4
    plugins:
      enabled: false
      repositories:
      - branch: ""
        name: ""
        path: ""
        repository: ""
    sync:
      args: []
      command: []
      extraEnvVars: []
      extraEnvVarsCM: ""
      extraEnvVarsSecret: ""
      extraVolumeMounts: []
      interval: 60
      resources: {}
  global:
    imagePullSecrets: []
    imageRegistry: ""
    storageClass: ""
  ingress:
    annotations: {}
    apiVersion: ""
    enabled: false
    extraHosts: []
    extraPaths: []
    extraRules: []
    extraTls: []
    hostname: airflow.local
    ingressClassName: ""
    path: /
    pathType: ImplementationSpecific
    secrets: []
    selfSigned: false
    tls: false
  initContainers: []
  kubeVersion: ""
  ldap:
    base: dc=ldap,dc=cetic,dc=be
    basedn: dc=example,dc=org
    binddn: cn=admin,dc=ldap,dc=cetic,dc=be
    bindpw: password1
    enabled: false
    rolesMapping: '{ "cn=All,ou=Groups,dc=example,dc=org": ["User"], "cn=Admins,ou=Groups,dc=example,dc=org":
      ["Admin"], }'
    rolesSyncAtLogin: "True"
    searchAttribute: cn
    tls:
      CAFilename: ""
      allowSelfSigned: true
      certificatesMountPath: /opt/bitnami/airflow/conf/certs
      certificatesSecret: ""
      enabled: false
    uidField: cn
    uri: ldap://fadi-openldap:389
    userRegistration: "True"
    userRegistrationRole: Public
  loadExamples: false
  metrics:
    affinity: {}
    containerPorts:
      http: 9112
    containerSecurityContext:
      enabled: true
      runAsNonRoot: true
      runAsUser: 1001
    enabled: false
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    hostAliases: []
    image:
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/airflow-exporter
      tag: 0.20220314.0-debian-11-r13
    lifecycleHooks: {}
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podSecurityContext:
      enabled: true
      fsGroup: 1001
    resources:
      limits: {}
      requests: {}
    schedulerName: ""
    service:
      annotations:
        prometheus.io/port: '{{ .Values.metrics.service.ports.http }}'
        prometheus.io/scrape: "true"
      clusterIP: ""
      ports:
        http: 9112
      sessionAffinity: None
    serviceMonitor:
      enabled: false
      honorLabels: false
      interval: ""
      jobLabel: ""
      labels: {}
      metricRelabelings: []
      namespace: ""
      relabelings: []
      scrapeTimeout: ""
      selector: {}
    tolerations: []
  nameOverride: ""
  postgresql:
    architecture: standalone
    audit:
      clientMinMessages: error
      logConnections: false
      logDisconnections: false
      logHostname: false
      logLinePrefix: ""
      logTimezone: ""
      pgAuditLog: ""
      pgAuditLogCatalog: "off"
    auth:
      database: bitnami_airflow
      enablePostgresUser: false
      existingSecret: ""
      password: ""
      postgresPassword: ""
      replicationPassword: ""
      replicationUsername: repl_user
      secretKeys:
        adminPasswordKey: postgres-password
        replicationPasswordKey: replication-password
        userPasswordKey: password
      usePasswordFiles: false
      username: bn_airflow
    clusterDomain: cluster.local
    common:
      exampleValue: common-chart
      global:
        imagePullSecrets: []
        imageRegistry: ""
        postgresql:
          auth:
            database: ""
            existingSecret: ""
            password: ""
            postgresPassword: ""
            secretKeys:
              adminPasswordKey: ""
              replicationPasswordKey: ""
              userPasswordKey: ""
            username: ""
          service:
            ports:
              postgresql: ""
        storageClass: ""
    commonAnnotations: {}
    commonLabels: {}
    containerPorts:
      postgresql: 5432
    diagnosticMode:
      args:
      - infinity
      command:
      - sleep
      enabled: false
    enabled: false
    extraDeploy: []
    fullnameOverride: ""
    global:
      imagePullSecrets: []
      imageRegistry: ""
      postgresql:
        auth:
          database: ""
          existingSecret: ""
          password: ""
          postgresPassword: ""
          secretKeys:
            adminPasswordKey: ""
            replicationPasswordKey: ""
            userPasswordKey: ""
          username: ""
        service:
          ports:
            postgresql: ""
      storageClass: ""
    image:
      debug: false
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/postgresql
      tag: 14.4.0-debian-11-r7
    kubeVersion: ""
    ldap:
      basedn: ""
      binddn: ""
      bindpw: ""
      enabled: false
      port: ""
      prefix: ""
      scheme: ""
      searchAttribute: ""
      searchFilter: ""
      server: ""
      suffix: ""
      tls:
        enabled: false
      uri: ""
    metrics:
      containerPorts:
        metrics: 9187
      containerSecurityContext:
        enabled: true
        runAsNonRoot: true
        runAsUser: 1001
      customLivenessProbe: {}
      customMetrics: {}
      customReadinessProbe: {}
      customStartupProbe: {}
      enabled: false
      extraEnvVars: []
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/postgres-exporter
        tag: 0.10.1-debian-11-r12
      livenessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      prometheusRule:
        enabled: false
        labels: {}
        namespace: ""
        rules: []
      readinessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      resources:
        limits: {}
        requests: {}
      service:
        annotations:
          prometheus.io/port: '{{ .Values.metrics.service.ports.metrics }}'
          prometheus.io/scrape: "true"
        clusterIP: ""
        ports:
          metrics: 9187
        sessionAffinity: None
      serviceMonitor:
        enabled: false
        honorLabels: false
        interval: ""
        jobLabel: ""
        labels: {}
        metricRelabelings: []
        namespace: ""
        relabelings: []
        scrapeTimeout: ""
        selector: {}
      startupProbe:
        enabled: false
        failureThreshold: 15
        initialDelaySeconds: 10
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 1
    nameOverride: ""
    networkPolicy:
      egressRules:
        customRules: {}
        denyConnectionsToExternal: false
      enabled: false
      ingressRules:
        primaryAccessOnlyFrom:
          customRules: {}
          enabled: false
          namespaceSelector: {}
          podSelector: {}
        readReplicasAccessOnlyFrom:
          customRules: {}
          enabled: false
          namespaceSelector: {}
          podSelector: {}
      metrics:
        enabled: false
        namespaceSelector: {}
        podSelector: {}
    postgresqlDataDir: /bitnami/postgresql/data
    postgresqlSharedPreloadLibraries: pgaudit
    primary:
      affinity: {}
      annotations: {}
      args: []
      command: []
      configuration: ""
      containerSecurityContext:
        enabled: true
        runAsUser: 1001
      customLivenessProbe: {}
      customReadinessProbe: {}
      customStartupProbe: {}
      existingConfigmap: ""
      existingExtendedConfigmap: ""
      extendedConfiguration: ""
      extraEnvVars: []
      extraEnvVarsCM: ""
      extraEnvVarsSecret: ""
      extraPodSpec: {}
      extraVolumeMounts: []
      extraVolumes: []
      hostAliases: []
      hostIPC: false
      hostNetwork: false
      initContainers: []
      initdb:
        args: ""
        password: ""
        postgresqlWalDir: ""
        scripts: {}
        scriptsConfigMap: ""
        scriptsSecret: ""
        user: ""
      labels: {}
      lifecycleHooks: {}
      livenessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 30
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      nodeAffinityPreset:
        key: ""
        type: ""
        values: []
      nodeSelector: {}
      persistence:
        accessModes:
        - ReadWriteOnce
        annotations: {}
        dataSource: {}
        enabled: true
        existingClaim: ""
        mountPath: /bitnami/postgresql
        selector: {}
        size: 8Gi
        storageClass: ""
        subPath: ""
      pgHbaConfiguration: ""
      podAffinityPreset: ""
      podAnnotations: {}
      podAntiAffinityPreset: soft
      podLabels: {}
      podSecurityContext:
        enabled: true
        fsGroup: 1001
      priorityClassName: ""
      readinessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      resources:
        limits: {}
        requests:
          cpu: 250m
          memory: 256Mi
      schedulerName: ""
      service:
        annotations: {}
        clusterIP: ""
        externalTrafficPolicy: Cluster
        extraPorts: []
        loadBalancerIP: ""
        loadBalancerSourceRanges: []
        nodePorts:
          postgresql: ""
        ports:
          postgresql: 5432
        sessionAffinity: None
        sessionAffinityConfig: {}
        type: ClusterIP
      sidecars: []
      standby:
        enabled: false
        primaryHost: ""
        primaryPort: ""
      startupProbe:
        enabled: false
        failureThreshold: 15
        initialDelaySeconds: 30
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 1
      terminationGracePeriodSeconds: ""
      tolerations: []
      topologySpreadConstraints: []
      updateStrategy:
        rollingUpdate: {}
        type: RollingUpdate
    psp:
      create: false
    rbac:
      create: false
      rules: []
    readReplicas:
      affinity: {}
      annotations: {}
      args: []
      command: []
      containerSecurityContext:
        enabled: true
        runAsUser: 1001
      customLivenessProbe: {}
      customReadinessProbe: {}
      customStartupProbe: {}
      extraEnvVars: []
      extraEnvVarsCM: ""
      extraEnvVarsSecret: ""
      extraPodSpec: {}
      extraVolumeMounts: []
      extraVolumes: []
      hostAliases: []
      hostIPC: false
      hostNetwork: false
      initContainers: []
      labels: {}
      lifecycleHooks: {}
      livenessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 30
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      nodeAffinityPreset:
        key: ""
        type: ""
        values: []
      nodeSelector: {}
      persistence:
        accessModes:
        - ReadWriteOnce
        annotations: {}
        dataSource: {}
        enabled: true
        mountPath: /bitnami/postgresql
        selector: {}
        size: 8Gi
        storageClass: ""
        subPath: ""
      podAffinityPreset: ""
      podAnnotations: {}
      podAntiAffinityPreset: soft
      podLabels: {}
      podSecurityContext:
        enabled: true
        fsGroup: 1001
      priorityClassName: ""
      readinessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      replicaCount: 1
      resources:
        limits: {}
        requests:
          cpu: 250m
          memory: 256Mi
      schedulerName: ""
      service:
        annotations: {}
        clusterIP: ""
        externalTrafficPolicy: Cluster
        extraPorts: []
        loadBalancerIP: ""
        loadBalancerSourceRanges: []
        nodePorts:
          postgresql: ""
        ports:
          postgresql: 5432
        sessionAffinity: None
        sessionAffinityConfig: {}
        type: ClusterIP
      sidecars: []
      startupProbe:
        enabled: false
        failureThreshold: 15
        initialDelaySeconds: 30
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 1
      terminationGracePeriodSeconds: ""
      tolerations: []
      topologySpreadConstraints: []
      updateStrategy:
        rollingUpdate: {}
        type: RollingUpdate
    replication:
      applicationName: my_application
      numSynchronousReplicas: 0
      synchronousCommit: "off"
    serviceAccount:
      annotations: {}
      automountServiceAccountToken: true
      create: false
      name: ""
    shmVolume:
      enabled: true
      sizeLimit: ""
    tls:
      autoGenerated: false
      certCAFilename: ""
      certFilename: ""
      certKeyFilename: ""
      certificatesSecret: ""
      crlFilename: ""
      enabled: false
      preferServerCiphers: true
    volumePermissions:
      containerSecurityContext:
        runAsUser: 0
      enabled: false
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/bitnami-shell
        tag: 11-debian-11-r12
      resources:
        limits: {}
        requests: {}
  rbac:
    create: false
    rules: []
  redis:
    architecture: standalone
    auth:
      enabled: true
      existingSecret: ""
      existingSecretPasswordKey: ""
      password: ""
      sentinel: true
      usePasswordFiles: false
    clusterDomain: cluster.local
    common:
      exampleValue: common-chart
      global:
        imagePullSecrets: []
        imageRegistry: ""
        redis:
          password: ""
        storageClass: ""
    commonAnnotations: {}
    commonConfiguration: |-
      # Enable AOF https://redis.io/topics/persistence#append-only-file
      appendonly yes
      # Disable RDB persistence, AOF persistence already enabled.
      save ""
    commonLabels: {}
    diagnosticMode:
      args:
      - infinity
      command:
      - sleep
      enabled: false
    enabled: true
    existingConfigmap: ""
    extraDeploy: []
    fullnameOverride: ""
    global:
      imagePullSecrets: []
      imageRegistry: ""
      redis:
        password: ""
      storageClass: ""
    image:
      debug: false
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/redis
      tag: 6.2.7-debian-11-r11
    kubeVersion: ""
    master:
      affinity: {}
      args: []
      command: []
      configuration: ""
      containerPorts:
        redis: 6379
      containerSecurityContext:
        enabled: true
        runAsUser: 1001
      count: 1
      customLivenessProbe: {}
      customReadinessProbe: {}
      customStartupProbe: {}
      disableCommands:
      - FLUSHDB
      - FLUSHALL
      dnsConfig: {}
      dnsPolicy: ""
      extraEnvVars: []
      extraEnvVarsCM: ""
      extraEnvVarsSecret: ""
      extraFlags: []
      extraVolumeMounts: []
      extraVolumes: []
      hostAliases: []
      initContainers: []
      kind: StatefulSet
      lifecycleHooks: {}
      livenessProbe:
        enabled: true
        failureThreshold: 5
        initialDelaySeconds: 20
        periodSeconds: 5
        successThreshold: 1
        timeoutSeconds: 5
      nodeAffinityPreset:
        key: ""
        type: ""
        values: []
      nodeSelector: {}
      persistence:
        accessModes:
        - ReadWriteOnce
        annotations: {}
        dataSource: {}
        enabled: true
        existingClaim: ""
        medium: ""
        path: /data
        selector: {}
        size: 8Gi
        sizeLimit: ""
        storageClass: ""
        subPath: ""
      podAffinityPreset: ""
      podAnnotations: {}
      podAntiAffinityPreset: soft
      podLabels: {}
      podSecurityContext:
        enabled: true
        fsGroup: 1001
      preExecCmds: []
      priorityClassName: ""
      readinessProbe:
        enabled: true
        failureThreshold: 5
        initialDelaySeconds: 20
        periodSeconds: 5
        successThreshold: 1
        timeoutSeconds: 1
      resources:
        limits: {}
        requests: {}
      schedulerName: ""
      service:
        annotations: {}
        clusterIP: ""
        externalTrafficPolicy: Cluster
        extraPorts: []
        internalTrafficPolicy: Cluster
        loadBalancerIP: ""
        loadBalancerSourceRanges: []
        nodePorts:
          redis: ""
        ports:
          redis: 6379
        sessionAffinity: None
        sessionAffinityConfig: {}
        type: ClusterIP
      shareProcessNamespace: false
      sidecars: []
      startupProbe:
        enabled: false
        failureThreshold: 5
        initialDelaySeconds: 20
        periodSeconds: 5
        successThreshold: 1
        timeoutSeconds: 5
      terminationGracePeriodSeconds: 30
      tolerations: []
      topologySpreadConstraints: []
      updateStrategy:
        rollingUpdate: {}
        type: RollingUpdate
    metrics:
      command: []
      containerSecurityContext:
        enabled: true
        runAsUser: 1001
      enabled: false
      extraArgs: {}
      extraEnvVars: []
      extraVolumeMounts: []
      extraVolumes: []
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/redis-exporter
        tag: 1.43.0-debian-11-r4
      podAnnotations:
        prometheus.io/port: "9121"
        prometheus.io/scrape: "true"
      podLabels: {}
      prometheusRule:
        additionalLabels: {}
        enabled: false
        namespace: ""
        rules: []
      redisTargetHost: localhost
      resources:
        limits: {}
        requests: {}
      service:
        annotations: {}
        externalTrafficPolicy: Cluster
        extraPorts: []
        loadBalancerIP: ""
        loadBalancerSourceRanges: []
        port: 9121
        type: ClusterIP
      serviceMonitor:
        additionalLabels: {}
        enabled: false
        honorLabels: false
        interval: 30s
        metricRelabelings: []
        namespace: ""
        relabellings: []
        scrapeTimeout: ""
    nameOverride: ""
    networkPolicy:
      allowExternal: true
      enabled: false
      extraEgress: []
      extraIngress: []
      ingressNSMatchLabels: {}
      ingressNSPodMatchLabels: {}
    password: password1
    pdb:
      create: false
      maxUnavailable: ""
      minAvailable: 1
    podSecurityPolicy:
      create: false
      enabled: false
    rbac:
      create: false
      rules: []
    replica:
      affinity: {}
      args: []
      autoscaling:
        enabled: false
        maxReplicas: 11
        minReplicas: 1
        targetCPU: ""
        targetMemory: ""
      command: []
      configuration: ""
      containerPorts:
        redis: 6379
      containerSecurityContext:
        enabled: true
        runAsUser: 1001
      customLivenessProbe: {}
      customReadinessProbe: {}
      customStartupProbe: {}
      disableCommands:
      - FLUSHDB
      - FLUSHALL
      dnsConfig: {}
      dnsPolicy: ""
      externalMaster:
        enabled: false
        host: ""
        port: 6379
      extraEnvVars: []
      extraEnvVarsCM: ""
      extraEnvVarsSecret: ""
      extraFlags: []
      extraVolumeMounts: []
      extraVolumes: []
      hostAliases: []
      initContainers: []
      lifecycleHooks: {}
      livenessProbe:
        enabled: true
        failureThreshold: 5
        initialDelaySeconds: 20
        periodSeconds: 5
        successThreshold: 1
        timeoutSeconds: 5
      nodeAffinityPreset:
        key: ""
        type: ""
        values: []
      nodeSelector: {}
      persistence:
        accessModes:
        - ReadWriteOnce
        annotations: {}
        dataSource: {}
        enabled: true
        existingClaim: ""
        medium: ""
        path: /data
        selector: {}
        size: 8Gi
        sizeLimit: ""
        storageClass: ""
        subPath: ""
      podAffinityPreset: ""
      podAnnotations: {}
      podAntiAffinityPreset: soft
      podLabels: {}
      podManagementPolicy: ""
      podSecurityContext:
        enabled: true
        fsGroup: 1001
      preExecCmds: []
      priorityClassName: ""
      readinessProbe:
        enabled: true
        failureThreshold: 5
        initialDelaySeconds: 20
        periodSeconds: 5
        successThreshold: 1
        timeoutSeconds: 1
      replicaCount: 3
      resources:
        limits: {}
        requests: {}
      schedulerName: ""
      service:
        annotations: {}
        clusterIP: ""
        externalTrafficPolicy: Cluster
        extraPorts: []
        internalTrafficPolicy: Cluster
        loadBalancerIP: ""
        loadBalancerSourceRanges: []
        nodePorts:
          redis: ""
        ports:
          redis: 6379
        sessionAffinity: None
        sessionAffinityConfig: {}
        type: ClusterIP
      shareProcessNamespace: false
      sidecars: []
      startupProbe:
        enabled: true
        failureThreshold: 22
        initialDelaySeconds: 10
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      terminationGracePeriodSeconds: 30
      tolerations: []
      topologySpreadConstraints: []
      updateStrategy:
        rollingUpdate: {}
        type: RollingUpdate
    secretAnnotations: {}
    sentinel:
      args: []
      automateClusterRecovery: false
      command: []
      configuration: ""
      containerPorts:
        sentinel: 26379
      containerSecurityContext:
        enabled: true
        runAsUser: 1001
      customLivenessProbe: {}
      customReadinessProbe: {}
      customStartupProbe: {}
      downAfterMilliseconds: 60000
      enabled: false
      externalMaster:
        enabled: false
        host: ""
        port: 6379
      extraEnvVars: []
      extraEnvVarsCM: ""
      extraEnvVarsSecret: ""
      extraVolumeMounts: []
      extraVolumes: []
      failoverTimeout: 18000
      getMasterTimeout: 220
      image:
        debug: false
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/redis-sentinel
        tag: 6.2.7-debian-11-r12
      lifecycleHooks: {}
      livenessProbe:
        enabled: true
        failureThreshold: 5
        initialDelaySeconds: 20
        periodSeconds: 5
        successThreshold: 1
        timeoutSeconds: 5
      masterSet: mymaster
      parallelSyncs: 1
      persistence:
        accessModes:
        - ReadWriteOnce
        annotations: {}
        dataSource: {}
        enabled: false
        medium: ""
        selector: {}
        size: 100Mi
        storageClass: ""
      preExecCmds: []
      quorum: 2
      readinessProbe:
        enabled: true
        failureThreshold: 5
        initialDelaySeconds: 20
        periodSeconds: 5
        successThreshold: 1
        timeoutSeconds: 1
      resources:
        limits: {}
        requests: {}
      service:
        annotations: {}
        clusterIP: ""
        externalTrafficPolicy: Cluster
        extraPorts: []
        loadBalancerIP: ""
        loadBalancerSourceRanges: []
        nodePorts:
          redis: ""
          sentinel: ""
        ports:
          redis: 6379
          sentinel: 26379
        sessionAffinity: None
        sessionAffinityConfig: {}
        type: ClusterIP
      startupProbe:
        enabled: true
        failureThreshold: 22
        initialDelaySeconds: 10
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      terminationGracePeriodSeconds: 30
    serviceAccount:
      annotations: {}
      automountServiceAccountToken: true
      create: true
      name: ""
    sysctl:
      command: []
      enabled: false
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/bitnami-shell
        tag: 11-debian-11-r11
      mountHostSys: false
      resources:
        limits: {}
        requests: {}
    tls:
      authClients: true
      autoGenerated: false
      certCAFilename: ""
      certFilename: ""
      certKeyFilename: ""
      certificatesSecret: ""
      dhParamsFilename: ""
      enabled: false
      existingSecret: ""
    useExternalDNS:
      additionalAnnotations: {}
      annotationKey: external-dns.alpha.kubernetes.io/
      enabled: false
      suffix: ""
    volumePermissions:
      containerSecurityContext:
        runAsUser: 0
      enabled: false
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/bitnami-shell
        tag: 11-debian-11-r11
      resources:
        limits: {}
        requests: {}
  scheduler:
    affinity: {}
    args: []
    command: []
    containerSecurityContext:
      enabled: true
      runAsNonRoot: true
      runAsUser: 1001
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraEnvVarsSecrets: []
    extraVolumeMounts: []
    extraVolumes: []
    hostAliases: []
    image:
      debug: false
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/airflow-scheduler
      tag: 2.3.3-debian-11-r0
    initContainers: []
    lifecycleHooks: {}
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    pdb:
      create: false
      maxUnavailable: ""
      minAvailable: 1
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podSecurityContext:
      enabled: true
      fsGroup: 1001
    priorityClassName: ""
    replicaCount: 1
    resources:
      limits: {}
      requests: {}
    schedulerName: ""
    sidecars: []
    terminationGracePeriodSeconds: ""
    tolerations: []
    topologySpreadConstraints: []
    updateStrategy:
      rollingUpdate: {}
      type: RollingUpdate
  service:
    annotations: {}
    clusterIP: ""
    externalTrafficPolicy: Cluster
    extraPorts: []
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    nodePorts:
      http: ""
    port: 8080
    ports:
      http: 8080
    sessionAffinity: None
    sessionAffinityConfig: {}
    type: ClusterIP
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: true
    create: false
    name: ""
  sidecars: []
  web:
    affinity: {}
    args: []
    baseUrl: ""
    command: []
    containerPorts:
      http: 8080
    containerSecurityContext:
      enabled: true
      runAsNonRoot: true
      runAsUser: 1001
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    existingConfigmap: ""
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraEnvVarsSecrets: []
    extraVolumeMounts: []
    extraVolumes: []
    hostAliases: []
    image:
      debug: false
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/airflow
      tag: 2.3.3-debian-11-r0
    initContainers: []
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 180
      periodSeconds: 20
      successThreshold: 1
      timeoutSeconds: 5
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    pdb:
      create: false
      maxUnavailable: ""
      minAvailable: 1
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podSecurityContext:
      enabled: true
      fsGroup: 1001
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    replicaCount: 1
    resources:
      limits: {}
      requests: {}
    schedulerName: ""
    sidecars: []
    startupProbe:
      enabled: false
      failureThreshold: 15
      initialDelaySeconds: 60
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1
    terminationGracePeriodSeconds: ""
    tolerations: []
    topologySpreadConstraints: []
    updateStrategy:
      rollingUpdate: {}
      type: RollingUpdate
  worker:
    affinity: {}
    args: []
    autoscaling:
      enabled: false
      maxReplicas: 3
      minReplicas: 1
      targetCPU: 80
      targetMemory: 80
    command: []
    containerPorts:
      http: 8793
    containerSecurityContext:
      enabled: true
      runAsNonRoot: true
      runAsUser: 1001
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraEnvVarsSecrets: []
    extraVolumeClaimTemplates: []
    extraVolumeMounts: []
    extraVolumes: []
    hostAliases: []
    image:
      debug: false
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/airflow-worker
      tag: 2.3.3-debian-11-r0
    initContainers: []
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 180
      periodSeconds: 20
      successThreshold: 1
      timeoutSeconds: 5
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    pdb:
      create: false
      maxUnavailable: ""
      minAvailable: 1
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podSecurityContext:
      enabled: true
      fsGroup: 1001
    podTemplate: {}
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    replicaCount: 1
    resources:
      limits: {}
      requests: {}
    schedulerName: ""
    sidecars: []
    startupProbe:
      enabled: false
      failureThreshold: 15
      initialDelaySeconds: 60
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1
    terminationGracePeriodSeconds: ""
    tolerations: []
    topologySpreadConstraints: []
    updateStrategy:
      rollingUpdate: {}
      type: RollingUpdate
cassandra:
  affinity: {}
  args: []
  cluster:
    clientEncryption: false
    datacenter: dc1
    enableUDF: false
    endpointSnitch: SimpleSnitch
    extraSeeds: []
    internodeEncryption: none
    name: cassandra
    numTokens: 256
    rack: rack1
    seedCount: 1
  clusterDomain: cluster.local
  command: []
  common:
    exampleValue: common-chart
    global:
      imagePullSecrets: []
      imageRegistry: ""
      storageClass: ""
  commonAnnotations: {}
  commonLabels: {}
  config:
    cluster_size: 1
    seed_size: 1
    start_rpc: true
  containerPorts:
    cql: 9042
    intra: 7000
    jmx: 7199
    tls: 7001
  containerSecurityContext:
    enabled: true
    runAsNonRoot: true
    runAsUser: 1001
  customLivenessProbe: {}
  customReadinessProbe: {}
  customStartupProbe: {}
  dbUser:
    existingSecret: ""
    forcePassword: false
    password: ""
    user: cassandra
  diagnosticMode:
    args:
    - infinity
    command:
    - sleep
    enabled: false
  enabled: false
  existingConfiguration: ""
  extraDeploy: []
  extraEnvVars: []
  extraEnvVarsCM: ""
  extraEnvVarsSecret: ""
  extraVolumeMounts: []
  extraVolumes: []
  fullnameOverride: ""
  global:
    imagePullSecrets: []
    imageRegistry: ""
    storageClass: ""
  hostAliases: []
  hostNetwork: false
  hostPorts:
    cql: ""
    intra: ""
    jmx: ""
    tls: ""
  image:
    debug: false
    digest: ""
    pullPolicy: IfNotPresent
    pullSecrets: []
    registry: docker.io
    repository: bitnami/cassandra
    tag: 4.0.7-debian-11-r0
  initContainers: []
  initDBConfigMap: ""
  initDBSecret: ""
  jvm:
    extraOpts: ""
    maxHeapSize: ""
    newHeapSize: ""
  kubeVersion: ""
  lifecycleHooks: {}
  livenessProbe:
    enabled: true
    failureThreshold: 5
    initialDelaySeconds: 60
    periodSeconds: 30
    successThreshold: 1
    timeoutSeconds: 30
  metrics:
    configuration: |
      host: localhost:{{ .Values.metrics.containerPorts.jmx }}
      ssl: False
      user:
      password:
      listenPort: {{ .Values.metrics.containerPorts.http }}
      blacklist:
        # To profile the duration of jmx call you can start the program with the following options
        # > java -Dorg.slf4j.simpleLogger.defaultLogLevel=trace -jar cassandra_exporter.jar config.yml --oneshot
        #
        # To get intuition of what is done by cassandra when something is called you can look in cassandra
        # https://github.com/apache/cassandra/tree/trunk/src/java/org/apache/cassandra/metrics
        # Please avoid to scrape frequently those calls that are iterating over all sstables

        # Unaccessible metrics (not enough privilege)
        - java:lang:memorypool:.*usagethreshold.*

        # Leaf attributes not interesting for us but that are presents in many path
        - .*:999thpercentile
        - .*:95thpercentile
        - .*:fifteenminuterate
        - .*:fiveminuterate
        - .*:durationunit
        - .*:rateunit
        - .*:stddev
        - .*:meanrate
        - .*:mean
        - .*:min

        # Path present in many metrics but uninterresting
        - .*:viewlockacquiretime:.*
        - .*:viewreadtime:.*
        - .*:cas[a-z]+latency:.*
        - .*:colupdatetimedeltahistogram:.*

        # Mostly for RPC, do not scrap them
        - org:apache:cassandra:db:.*

        # columnfamily is an alias for Table metrics
        # https://github.com/apache/cassandra/blob/8b3a60b9a7dbefeecc06bace617279612ec7092d/src/java/org/apache/cassandra/metrics/TableMetrics.java#L162
        - org:apache:cassandra:metrics:columnfamily:.*

        # Should we export metrics for system keyspaces/tables ?
        - org:apache:cassandra:metrics:[^:]+:system[^:]*:.*

        # Don't scrap us
        - com:criteo:nosql:cassandra:exporter:.*

      maxScrapFrequencyInSec:
        50:
          - .*

        # Refresh those metrics only every hour as it is costly for cassandra to retrieve them
        3600:
          - .*:snapshotssize:.*
          - .*:estimated.*
          - .*:totaldiskspaceused:.*
    containerPorts:
      http: 8080
      jmx: 5555
    enabled: false
    extraVolumeMounts: []
    hostPorts:
      http: ""
      jmx: ""
    image:
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/cassandra-exporter
      tag: 2.3.8-debian-11-r51
    podAnnotations:
      prometheus.io/port: "8080"
      prometheus.io/scrape: "true"
    readinessProbe:
      failureThreshold: 3
      initialDelaySeconds: 20
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 45
    resources:
      limits: {}
      requests: {}
    serviceMonitor:
      enabled: false
      honorLabels: false
      interval: ""
      jobLabel: ""
      labels: {}
      metricRelabelings: []
      namespace: monitoring
      relabelings: []
      scrapeTimeout: ""
      selector: {}
  nameOverride: ""
  networkPolicy:
    allowExternal: true
    enabled: false
  nodeAffinityPreset:
    key: ""
    type: ""
    values: []
  nodeSelector: {}
  pdb:
    create: false
    maxUnavailable: ""
    minAvailable: 1
  persistence:
    accessModes:
    - ReadWriteOnce
    annotations: {}
    commitLogMountPath: ""
    commitLogsize: 2Gi
    commitStorageClass: ""
    enabled: true
    mountPath: /bitnami/cassandra
    size: 8Gi
    storageClass: ""
  podAffinityPreset: ""
  podAnnotations: {}
  podAntiAffinityPreset: soft
  podLabels: {}
  podManagementPolicy: OrderedReady
  podSecurityContext:
    enabled: true
    fsGroup: 1001
  priorityClassName: ""
  readinessProbe:
    enabled: true
    failureThreshold: 5
    initialDelaySeconds: 60
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 30
  replicaCount: 1
  resources:
    limits: {}
    requests: {}
  schedulerName: ""
  service:
    annotations: {}
    clusterIP: ""
    externalTrafficPolicy: Cluster
    extraPorts: []
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    nodePorts:
      cql: ""
      metrics: ""
    ports:
      cql: 9042
      metrics: 8080
    sessionAffinity: None
    sessionAffinityConfig: {}
    type: ClusterIP
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: true
    create: true
    name: ""
  sidecars: []
  startupProbe:
    enabled: false
    failureThreshold: 60
    initialDelaySeconds: 0
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 5
  terminationGracePeriodSeconds: ""
  tls:
    autoGenerated: false
    certificatesSecret: ""
    clientEncryption: false
    existingSecret: ""
    internodeEncryption: none
    keystorePassword: ""
    passwordsSecret: ""
    resources:
      limits: {}
      requests: {}
    tlsEncryptionSecretName: ""
    truststorePassword: ""
  tolerations: []
  topologySpreadConstraints: []
  updateStrategy:
    type: RollingUpdate
  volumePermissions:
    enabled: false
    image:
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/bitnami-shell
      tag: 11-debian-11-r44
    resources:
      limits: {}
      requests: {}
    securityContext:
      runAsUser: 0
cert-manager:
  affinity: {}
  cainjector:
    affinity: {}
    containerSecurityContext: {}
    enabled: true
    extraArgs: []
    image:
      pullPolicy: IfNotPresent
      repository: quay.io/jetstack/cert-manager-cainjector
    nodeSelector: {}
    podLabels: {}
    replicaCount: 1
    resources: {}
    securityContext:
      runAsNonRoot: true
    serviceAccount:
      automountServiceAccountToken: true
      create: true
    strategy: {}
    tolerations: []
  clusterResourceNamespace: ""
  containerSecurityContext: {}
  enabled: false
  extraArgs: []
  extraEnv: []
  featureGates: ""
  global:
    imagePullSecrets: []
    leaderElection:
      namespace: kube-system
    logLevel: 2
    podSecurityPolicy:
      enabled: false
      useAppArmor: true
    priorityClassName: ""
    rbac:
      create: true
  image:
    pullPolicy: IfNotPresent
    repository: quay.io/jetstack/cert-manager-controller
  ingressShim: {}
  installCRDs: true
  nodeSelector: {}
  podLabels: {}
  prometheus:
    enabled: true
    servicemonitor:
      enabled: false
      honorLabels: false
      interval: 60s
      labels: {}
      path: /metrics
      prometheusInstance: default
      scrapeTimeout: 30s
      targetPort: 9402
  replicaCount: 1
  resources: {}
  securityContext:
    runAsNonRoot: true
  serviceAccount:
    automountServiceAccountToken: true
    create: true
  startupapicheck:
    affinity: {}
    backoffLimit: 4
    enabled: true
    extraArgs: []
    image:
      pullPolicy: IfNotPresent
      repository: quay.io/jetstack/cert-manager-ctl
    jobAnnotations:
      helm.sh/hook: post-install
      helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
      helm.sh/hook-weight: "1"
    nodeSelector: {}
    podLabels: {}
    rbac:
      annotations:
        helm.sh/hook: post-install
        helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
        helm.sh/hook-weight: "-5"
    resources: {}
    securityContext:
      runAsNonRoot: true
    serviceAccount:
      annotations:
        helm.sh/hook: post-install
        helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
        helm.sh/hook-weight: "-5"
      automountServiceAccountToken: true
      create: true
    timeout: 1m
    tolerations: []
  strategy: {}
  tolerations: []
  volumeMounts: []
  volumes: []
  webhook:
    affinity: {}
    config: null
    containerSecurityContext: {}
    extraArgs: []
    hostNetwork: false
    image:
      pullPolicy: IfNotPresent
      repository: quay.io/jetstack/cert-manager-webhook
    livenessProbe:
      failureThreshold: 3
      initialDelaySeconds: 60
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1
    nodeSelector: {}
    podLabels: {}
    readinessProbe:
      failureThreshold: 3
      initialDelaySeconds: 5
      periodSeconds: 5
      successThreshold: 1
      timeoutSeconds: 1
    replicaCount: 1
    resources: {}
    securePort: 10250
    securityContext:
      runAsNonRoot: true
    serviceAccount:
      automountServiceAccountToken: true
      create: true
    serviceLabels: {}
    serviceType: ClusterIP
    strategy: {}
    timeoutSeconds: 10
    tolerations: []
    url: {}
clusterIssuer:
  email: <your_e-mail_address>
  enabled: false
  prod: false
drupal:
  affinity: {}
  enabled: false
  fullnameOverride: ""
  global: {}
  image:
    pullPolicy: IfNotPresent
    repository: drupal
    tag: 8-apache
  imagePullSecrets: []
  ingress:
    annotations: {}
    enabled: false
    hostname: null
    hosts:
    - host: null
      paths:
      - /
    tls: []
  nameOverride: ""
  nodeSelector: {}
  podSecurityContext: {}
  replicaCount: 1
  resources: {}
  securityContext: {}
  service:
    port: 80
    type: NodePort
  serviceAccount:
    create: true
    name: null
  tolerations: []
elasticsearch:
  antiAffinity: hard
  antiAffinityTopologyKey: kubernetes.io/hostname
  clusterDeprecationIndexing: "false"
  clusterHealthCheckParams: wait_for_status=green&timeout=1s
  clusterName: elasticsearch
  enableServiceLinks: true
  enabled: false
  envFrom: []
  esConfig: {}
  esJavaOpts: ""
  esJvmOptions: {}
  esMajorVersion: ""
  extraContainers: []
  extraEnvs: []
  extraInitContainers: []
  extraVolumeMounts: []
  extraVolumes: []
  fsGroup: ""
  fullnameOverride: ""
  global: {}
  healthNameOverride: ""
  hostAliases: []
  httpPort: 9200
  image: docker.elastic.co/elasticsearch/elasticsearch
  imagePullPolicy: IfNotPresent
  imagePullSecrets: []
  imageTag: 7.17.3
  ingress:
    annotations: {}
    className: nginx
    enabled: false
    hosts:
    - host: chart-example.local
      paths:
      - path: /
    pathtype: ImplementationSpecific
    tls: []
  initResources: {}
  keystore: []
  labels: {}
  lifecycle: {}
  masterService: ""
  maxUnavailable: 1
  minimumMasterNodes: 2
  nameOverride: ""
  networkHost: 0.0.0.0
  networkPolicy:
    http:
      enabled: false
    transport:
      enabled: false
  nodeAffinity: {}
  nodeGroup: master
  nodeSelector: {}
  persistence:
    annotations: {}
    enabled: true
    labels:
      enabled: false
  podAnnotations: {}
  podManagementPolicy: Parallel
  podSecurityContext:
    fsGroup: 1000
    runAsUser: 1000
  podSecurityPolicy:
    create: false
    name: ""
    spec:
      fsGroup:
        rule: RunAsAny
      privileged: true
      runAsUser:
        rule: RunAsAny
      seLinux:
        rule: RunAsAny
      supplementalGroups:
        rule: RunAsAny
      volumes:
      - secret
      - configMap
      - persistentVolumeClaim
      - emptyDir
  priorityClassName: ""
  protocol: http
  rbac:
    automountToken: true
    create: false
    serviceAccountAnnotations: {}
    serviceAccountName: ""
  readinessProbe:
    failureThreshold: 3
    initialDelaySeconds: 10
    periodSeconds: 10
    successThreshold: 3
    timeoutSeconds: 5
  replicas: 3
  resources:
    limits:
      cpu: 1000m
      memory: 2Gi
    requests:
      cpu: 1000m
      memory: 2Gi
  roles:
    data: "true"
    ingest: "true"
    master: "true"
    ml: "true"
    remote_cluster_client: "true"
  schedulerName: ""
  secretMounts: []
  securityContext:
    capabilities:
      drop:
      - ALL
    runAsNonRoot: true
    runAsUser: 1000
  service:
    annotations: {}
    enabled: true
    externalTrafficPolicy: ""
    httpPortName: http
    labels: {}
    labelsHeadless: {}
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    nodePort: ""
    publishNotReadyAddresses: false
    transportPortName: transport
    type: ClusterIP
  sysctlInitContainer:
    enabled: true
  sysctlVmMaxMapCount: 262144
  terminationGracePeriod: 120
  tests:
    enabled: true
  tolerations: []
  transportPort: 9300
  updateStrategy: RollingUpdate
  volumeClaimTemplate:
    accessModes:
    - ReadWriteOnce
    resources:
      requests:
        storage: 30Gi
fadeployer:
  annotations: {}
  enabled: true
  env:
    DATABASE_ENGINE: postgresql_psycopg2
    DATABASE_HOST: fadi-postgresql
    DATABASE_NAME: postgres
    DATABASE_PASSWORD: Z2JHHezi4aAA
    DATABASE_USERNAME: admin
    DEBUG: "True"
    DJANGO_LOGLEVEL: info
    MINIO_ACCESS_KEY: TShGemD0Ix
    MINIO_ENDPOINT: fadi-minio:9000
    MINIO_EXTERNAL_ENDPOINT: fadi-minio:9000
    MINIO_SECRET_KEY: LcCbxVDXlD
  environment: {}
  fadeployer:
    replicaCount: 1
  fullnameOverride: ""
  global: {}
  image:
    pullPolicy: Always
    repository: nexus.cetic.be:8125/fadeployer
    tag: "2"
  imagePullSecrets: secret-nexus-docker
  ingress:
    annotations: {}
    enabled: false
    hosts:
    - host: chart-example.local
      path: /
      serviceName: web
      servicePort: 8000
    tls: []
  init:
    migrations:
      command: python manage.py initialize_buckets && yes | python manage.py makemigrations
        && python manage.py migrate
      name: migrations
  liveness:
    enabled: false
    initialDelaySeconds: 3
    path: /alive
    periodSeconds: 3
    port: 8001
  nameOverride: ""
  readiness:
    enabled: false
    failureThreshold: 3
    initialDelaySeconds: 5
    path: /ready
    periodSeconds: 5
    port: 8001
  resources:
    limits:
      cpu: 2
      memory: 2000Mi
    requests:
      cpu: 500m
      memory: 500Mi
  services:
  - annotations: {}
    name: web
    port: 8000
    specs:
    - name: http
      nodePort: 30091
      port: 8000
      targetPort: 8000
    type: LoadBalancer
  volumes:
    enabled: false
    pvc:
      accessModes:
      - ReadWriteOnce
      enabled: false
      mountPath: /pv
      name: pvc
      size: 5G
filebeat:
  affinity: {}
  clusterRoleRules:
  - apiGroups:
    - ""
    resources:
    - namespaces
    - nodes
    - pods
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - apps
    resources:
    - replicasets
    verbs:
    - get
    - list
    - watch
  config:
    output.file.enabled: false
    output.logstash:
      hosts:
      - fadi-logstash:5044
  daemonset:
    affinity: {}
    annotations: {}
    enabled: true
    envFrom: []
    extraEnvs: []
    extraVolumeMounts: []
    extraVolumes: []
    filebeatConfig:
      filebeat.yml: |
        filebeat.inputs:
        - type: container
          paths:
            - /var/log/containers/*.log
          processors:
          - add_kubernetes_metadata:
              host: ${NODE_NAME}
              matchers:
              - logs_path:
                  logs_path: "/var/log/containers/"

        output.elasticsearch:
          host: '${NODE_NAME}'
          hosts: '${ELASTICSEARCH_HOSTS:elasticsearch-master:9200}'
    hostNetworking: false
    labels: {}
    maxUnavailable: 1
    nodeSelector: {}
    resources:
      limits:
        cpu: 1000m
        memory: 200Mi
      requests:
        cpu: 100m
        memory: 100Mi
    secretMounts: []
    securityContext:
      privileged: false
      runAsUser: 0
    tolerations: []
  deployment:
    affinity: {}
    annotations: {}
    enabled: false
    envFrom: []
    extraEnvs: []
    extraVolumeMounts: []
    extraVolumes: []
    filebeatConfig:
      filebeat.yml: |
        filebeat.inputs:
        - type: tcp
          max_message_size: 10MiB
          host: "localhost:9000"

        output.elasticsearch:
          host: '${NODE_NAME}'
          hosts: '${ELASTICSEARCH_HOSTS:elasticsearch-master:9200}'
    labels: {}
    nodeSelector: {}
    resources:
      limits:
        cpu: 1000m
        memory: 200Mi
      requests:
        cpu: 100m
        memory: 100Mi
    secretMounts: []
    securityContext:
      privileged: false
      runAsUser: 0
    tolerations: []
  dnsConfig: {}
  enabled: false
  envFrom: []
  extraContainers: ""
  extraEnvs: []
  extraInitContainers: []
  extraVolumeMounts: []
  extraVolumes: []
  filebeatConfig: {}
  fullnameOverride: ""
  global: {}
  hostAliases: []
  hostPathRoot: /var/lib
  image: docker.elastic.co/beats/filebeat
  imagePullPolicy: IfNotPresent
  imagePullSecrets: []
  imageTag: 7.17.3
  indexTemplateLoad:
  - fadi-elasticsearch-client:9200
  labels: {}
  livenessProbe:
    exec:
      command:
      - sh
      - -c
      - |
        #!/usr/bin/env bash -e
        curl --fail 127.0.0.1:5066
    failureThreshold: 3
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
  managedServiceAccount: true
  nameOverride: ""
  nodeSelector: {}
  podAnnotations: {}
  podSecurityContext: {}
  priorityClassName: ""
  readinessProbe:
    exec:
      command:
      - sh
      - -c
      - |
        #!/usr/bin/env bash -e
        filebeat test output
    failureThreshold: 3
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
  replicas: 1
  resources: {}
  secretMounts: []
  serviceAccount: ""
  serviceAccountAnnotations: {}
  terminationGracePeriod: 30
  tolerations: []
  updateStrategy: RollingUpdate
grafana:
  admin:
    existingSecret: ""
    passwordKey: admin-password
    userKey: admin-user
  adminUser: admin
  affinity: {}
  containerSecurityContext: {}
  dashboardProviders: {}
  dashboards: {}
  dashboardsConfigMaps: {}
  datasources: {}
  deploymentStrategy:
    type: RollingUpdate
  downloadDashboards:
    env: {}
    resources: {}
  downloadDashboardsImage:
    pullPolicy: IfNotPresent
    repository: curlimages/curl
    sha: ""
    tag: 7.73.0
  enabled: true
  env: {}
  envFromSecret: ""
  envRenderSecret: {}
  envValueFrom: {}
  extraConfigmapMounts: []
  extraContainerVolumes: []
  extraContainers: ""
  extraEmptyDirMounts: []
  extraExposePorts: []
  extraInitContainers: []
  extraSecretMounts: []
  extraVolumeMounts: []
  global: {}
  grafana.ini:
    analytics:
      check_for_updates: true
    auth.azuread:
      allow_sign_up: true
      allowed_domains: null
      allowed_groups: null
      auth_url: https://login.microsoftonline.com/<your_tenant_id>/oauth2/v2.0/authorize
      client_id: <your_application_id>
      client_secret: <your_client_secret>
      enabled: false
      name: Azure AD
      scopes: openid email profile
      token_url: https://login.microsoftonline.com/<your_tenant_id>/oauth2/v2.0/token
    auth.generic_oauth:
      allow_sign_up: true
      api_url: http://<your_keycloak_URL>/auth/realms/<your_realm>/protocol/openid-connect/userinfo
      auth_url: http://<your_keycloak_URL>/auth/realms/<your_realm>/protocol/openid-connect/auth
      client_id: <your_client_id>
      client_secret: <your_client_secret>
      enabled: false
      name: Keycloak
      scopes: openid email profile
      tls_skip_verify_insecure: false
      token_url: http://<your_keycloak_URL>/auth/realms/<your_realm>/protocol/openid-connect/token
    auth.ldap:
      allow_sign_up: true
      config_file: /etc/grafana/ldap.toml
      enabled: true
    grafana_net:
      url: https://grafana.net
    log:
      mode: console
    paths:
      data: /var/lib/grafana/data
      logs: /var/log/grafana
      plugins: /var/lib/grafana/plugins
      provisioning: /etc/grafana/provisioning
    server:
      root_url: http://grafana.example.cetic.be
  hostAliases: []
  image:
    pullPolicy: IfNotPresent
    repository: grafana/grafana
    sha: ""
    tag: 7.3.5
  imageRenderer:
    enabled: false
    env:
      HTTP_HOST: 0.0.0.0
    hostAliases: []
    image:
      pullPolicy: Always
      repository: grafana/grafana-image-renderer
      sha: ""
      tag: latest
    networkPolicy:
      limitEgress: false
      limitIngress: true
    podPortName: http
    priorityClassName: ""
    replicas: 1
    resources: {}
    revisionHistoryLimit: 10
    securityContext: {}
    service:
      port: 8081
      portName: http
      targetPort: 8081
  ingress:
    annotations: {}
    enabled: false
    extraPaths: []
    hosts:
    - chart-example.local
    labels: {}
    path: /
    tls: []
  initChownData:
    enabled: true
    image:
      pullPolicy: IfNotPresent
      repository: busybox
      sha: ""
      tag: 1.31.1
    resources: {}
  ldap:
    config: |-
      verbose_logging = true
      [[servers]]
      host = "fadi-openldap"
      port = 389
      use_ssl = false
      start_tls = false
      ssl_skip_verify = false
      bind_dn = "cn=admin,DC=ldap,DC=cetic,DC=be"
      bind_password = 'password1'
      search_filter = "(|(cn=%s)(&(cn=%s)(memberOf=cn=admin,DC=ldap,DC=cetic,DC=be)))"
      search_base_dns = ["cn=admin,dc=ldap,dc=cetic,dc=be"]
      group_search_base_dns = ["ou=Groups,dc=ldap,dc=cetic,dc=be"]

      [[servers.group_mappings]]
      group_dn = "*"
      org_role = "Admin"
      ##grafana_admin = true

      #group_dn = "cn=amen,DC=ldap,DC=cetic,DC=be"
      #org_role = "Viewer"

      [servers.attributes]
      name = "givenName"
      surname = "sn"
      username = "cn"
      member_of = "memberOf"
      email =  "email"
    enabled: true
    existingSecret: ""
  livenessProbe:
    failureThreshold: 10
    httpGet:
      path: /api/health
      port: 3000
    initialDelaySeconds: 60
    timeoutSeconds: 30
  namespaceOverride: ""
  nodeSelector: {}
  notifiers: {}
  persistence:
    accessModes:
    - ReadWriteOnce
    enabled: true
    finalizers:
    - kubernetes.io/pvc-protection
    size: 10Gi
    type: pvc
  plugins: []
  podDisruptionBudget: {}
  podPortName: grafana
  rbac:
    create: true
    extraClusterRoleRules: []
    extraRoleRules: []
    namespaced: false
    pspEnabled: true
    pspUseAppArmor: true
  readinessProbe:
    httpGet:
      path: /api/health
      port: 3000
  replicas: 1
  resources: {}
  revisionHistoryLimit: 10
  securityContext:
    fsGroup: 472
    runAsGroup: 472
    runAsUser: 472
  service:
    annotations: {}
    labels: {}
    port: 80
    portName: service
    targetPort: 3000
    type: ClusterIP
  serviceAccount:
    create: true
  serviceMonitor:
    enabled: false
    interval: 1m
    labels: {}
    path: /metrics
    relabelings: []
    scheme: http
    scrapeTimeout: 30s
    tlsConfig: {}
  sidecar:
    dashboards:
      SCProvider: true
      enabled: false
      folder: /tmp/dashboards
      label: grafana_dashboard
      provider:
        allowUiUpdates: false
        disableDelete: false
        folder: ""
        foldersFromFilesStructure: false
        name: sidecarProvider
        orgid: 1
        type: file
    datasources:
      enabled: false
      label: grafana_datasource
    enableUniqueFilenames: false
    image:
      repository: kiwigrid/k8s-sidecar
      sha: ""
      tag: 1.1.0
    imagePullPolicy: IfNotPresent
    notifiers:
      enabled: false
      label: grafana_notifier
    resources: {}
  smtp:
    existingSecret: ""
    passwordKey: password
    userKey: user
  testFramework:
    enabled: true
    image: bats/bats
    imagePullPolicy: IfNotPresent
    securityContext: {}
    tag: v1.1.0
  tolerations: []
  traefikIngress:
    enabled: true
    host: grafana.example.cetic.be
    tls: false
influxdb:
  architecture: standalone
  auth:
    admin:
      bucket: primary
      org: primary
      password: ""
      token: ""
      username: admin
    createUserToken: false
    enabled: true
    existingSecret: ""
    readUser:
      password: ""
      username: ""
    usePasswordFiles: false
    user:
      bucket: ""
      org: ""
      password: ""
      username: ""
    writeUser:
      password: ""
      username: ""
  backup:
    affinity: {}
    cronjob:
      historyLimit: 1
      podAnnotations: {}
      schedule: 0 2 * * *
      securityContext:
        enabled: true
        fsGroup: 1001
        runAsUser: 1001
    directory: /backups
    enabled: false
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    podAffinityPreset: ""
    podAntiAffinityPreset: soft
    retentionDays: 10
    tolerations: []
    uploadProviders:
      aws:
        accessKeyID: ""
        bucketName: s3://bucket/influxdb
        enabled: false
        existingSecret: ""
        image:
          pullPolicy: IfNotPresent
          pullSecrets: []
          registry: docker.io
          repository: bitnami/aws-cli
          tag: 2.4.7-debian-10-r4
        region: us-east-1
        secretAccessKey: ""
      azure:
        containerName: influxdb-container
        enabled: false
        existingSecret: ""
        image:
          pullPolicy: IfNotPresent
          pullSecrets: []
          registry: docker.io
          repository: bitnami/azure-cli
          tag: 2.32.0-debian-10-r12
        secret: ""
        secretKey: connection-string
      google:
        bucketName: gs://bucket/influxdb
        enabled: false
        existingSecret: ""
        image:
          pullPolicy: IfNotPresent
          pullSecrets: []
          registry: docker.io
          repository: bitnami/google-cloud-sdk
          tag: 0.368.0-debian-10-r5
        secret: ""
        secretKey: key.json
  clusterDomain: cluster.local
  collectd:
    enabled: false
    service:
      annotations: {}
      clusterIP: ""
      loadBalancerIP: ""
      loadBalancerSourceRanges: []
      nodePort: ""
      port: 25826
      type: ClusterIP
  common:
    exampleValue: common-chart
    global:
      imagePullSecrets: []
      imageRegistry: ""
      storageClass: ""
  commonAnnotations: {}
  commonLabels: {}
  diagnosticMode:
    args:
    - infinity
    command:
    - sleep
    enabled: false
  enabled: false
  extraDeploy: []
  fullnameOverride: ""
  global:
    imagePullSecrets: []
    imageRegistry: ""
    storageClass: ""
  image:
    debug: false
    pullPolicy: IfNotPresent
    pullSecrets: []
    registry: docker.io
    repository: bitnami/influxdb
    tag: 2.1.1-debian-10-r46
  influxdb:
    affinity: {}
    configuration: ""
    containerPorts:
      http: 8086
      rpc: 8088
    customLivenessProbe: {}
    customReadinessProbe: {}
    existingConfiguration: ""
    extraEnvVars: []
    extraVolumeMounts: []
    extraVolumes: []
    initdbScripts: {}
    initdbScriptsCM: ""
    initdbScriptsSecret: ""
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 180
      periodSeconds: 45
      successThreshold: 1
      timeoutSeconds: 30
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    podAffinityPreset: ""
    podAntiAffinityPreset: soft
    podManagementPolicy: OrderedReady
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 60
      periodSeconds: 45
      successThreshold: 1
      timeoutSeconds: 30
    replicaCount: 1
    resources:
      limits: {}
      requests: {}
    securityContext:
      enabled: true
      fsGroup: 1001
      runAsUser: 1001
    service:
      annotations: {}
      clusterIP: ""
      loadBalancerIP: ""
      loadBalancerSourceRanges: []
      nodePorts:
        http: ""
        rpc: ""
      port: 8086
      rpcPort: 8088
      sessionAffinity: ""
      sessionAffinityConfig: {}
      type: ClusterIP
    tolerations: []
    updateStrategy: RollingUpdate
  ingress:
    annotations: {}
    apiVersion: ""
    enabled: false
    extraHosts: []
    extraPaths: []
    extraTls: []
    hostname: influxdb.local
    path: /
    pathType: ImplementationSpecific
    secrets: []
    tls: false
  kubeVersion: ""
  metrics:
    enabled: false
    service:
      annotations:
        prometheus.io/path: /metrics
        prometheus.io/port: '{{ .Values.influxdb.service.port }}'
        prometheus.io/scrape: "true"
      clusterIP: ""
      loadBalancerIP: ""
      loadBalancerSourceRanges: []
      nodePort: ""
      port: 9122
      type: ClusterIP
    serviceMonitor:
      enabled: false
      interval: ""
      namespace: ""
      scrapeTimeout: ""
      selector: {}
  nameOverride: ""
  networkPolicy:
    allowExternal: true
    enabled: false
  persistence:
    accessModes:
    - ReadWriteOnce
    enabled: true
    existingClaim: ""
    size: 8Gi
    storageClass: ""
  psp:
    create: false
  rbac:
    create: false
  relay:
    affinity: {}
    configuration: |-
      [[http]]
      # Name of the HTTP server, used for display purposes only.
      name = "relay-server"

      # TCP address to bind to, for HTTP server.
      bind-addr = "0.0.0.0:9096"

      # Array of InfluxDB&trade; instances to use as backends for Relay.
      output = [
          {{- $influxdbReplicaCount := int .Values.influxdb.replicaCount }}
          {{- $influxdbFullname := include "common.names.fullname" . }}
          {{- $influxdbHeadlessServiceName := printf "%s-headless" (include "common.names.fullname" .) }}
          {{- $releaseName := .Release.Namespace }}
          {{- $clusterDomain:= .Values.clusterDomain }}
          {{- range $e, $i := until $influxdbReplicaCount }}
          { name="{{ $influxdbFullname }}-{{ $i }}", location="http://{{ $influxdbFullname }}-{{ $i }}.{{ $influxdbHeadlessServiceName }}.{{ $releaseName }}.svc.{{ $clusterDomain }}:8086/write", timeout="10s"},
          {{- end }}
      ]
    containerPorts:
      http: 9096
    customLivenessProbe: {}
    customReadinessProbe: {}
    existingConfiguration: ""
    extraVolumeMounts: []
    extraVolumes: []
    image:
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/influxdb-relay
      tag: 0.20200717.0-scratch-r14
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    podAffinityPreset: ""
    podAntiAffinityPreset: soft
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    replicaCount: 1
    resources:
      limits: {}
      requests: {}
    securityContext:
      enabled: true
      fsGroup: 1001
      runAsUser: 1001
    service:
      annotations: {}
      clusterIP: ""
      loadBalancerIP: ""
      loadBalancerSourceRanges: []
      nodePort: ""
      port: 9096
      type: ClusterIP
    tolerations: []
    updateStrategy: RollingUpdate
  serviceAccount:
    enabled: false
    name: ""
  volumePermissions:
    enabled: false
    image:
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/bitnami-shell
      tag: 10-debian-10-r312
    securityContext:
      runAsUser: 0
jupyterhub:
  cull:
    concurrency: 10
    enabled: true
    every: 600
    maxAge: 0
    removeNamedServers: false
    timeout: 3600
    users: false
  custom: {}
  debug:
    enabled: false
  enabled: true
  global: {}
  hub:
    activeServerLimit: null
    allowNamedServers: false
    annotations: {}
    args: []
    authenticatePrometheus: null
    baseUrl: /
    command: []
    concurrentSpawnLimit: 64
    config:
      JupyterHub:
        admin_access: true
        authenticator_class: ldapauthenticator.LDAPAuthenticator
      LDAPAuthenticator:
        bind_dn_template:
        - cn={username},dc=ldap,dc=cetic,dc=be
        - cn={username},cn=admin,dc=ldap,dc=cetic,dc=be
        escape_userdn: false
        lookup_dn: false
        server_address: fadi-openldap
        use_ssl: false
        user_attribute: cn
    consecutiveFailureLimit: 5
    containerSecurityContext:
      allowPrivilegeEscalation: false
      runAsGroup: 1000
      runAsUser: 1000
    cookieSecret: null
    db:
      pvc:
        accessModes:
        - ReadWriteOnce
        annotations: {}
        selector: {}
        storage: 1Gi
      type: sqlite-pvc
    deploymentStrategy:
      type: Recreate
    existingSecret: null
    extraConfig: {}
    extraConfigMap: {}
    extraContainers: []
    extraEnv: {}
    extraVolumeMounts: []
    extraVolumes: []
    fsGid: 1000
    image:
      name: jupyterhub/k8s-hub
      pullPolicy: ""
      pullSecrets: []
      tag: 0.11.1
    initContainers: []
    labels: {}
    livenessProbe:
      enabled: true
      failureThreshold: 30
      initialDelaySeconds: 300
      periodSeconds: 10
      timeoutSeconds: 3
    namedServerLimitPerUser: null
    networkPolicy:
      allowedIngressPorts: []
      egress:
      - to:
        - ipBlock:
            cidr: 0.0.0.0/0
      enabled: true
      ingress: []
      interNamespaceAccessLabels: ignore
    nodeSelector: {}
    pdb:
      enabled: false
      minAvailable: 1
    publicURL: null
    readinessProbe:
      enabled: true
      failureThreshold: 1000
      initialDelaySeconds: 0
      periodSeconds: 2
      timeoutSeconds: 1
    redirectToServer: null
    resources:
      requests:
        cpu: 200m
        memory: 512Mi
    service:
      annotations: {}
      ports: {}
      type: ClusterIP
    services: {}
    shutdownOnLogout: null
    templatePaths: []
    templateVars: {}
    tolerations: []
  imagePullSecret:
    automaticReferenceInjection: true
    create: false
    email: ""
    password: ""
    registry: ""
    username: ""
  imagePullSecrets: []
  ingress:
    annotations: {}
    enabled: false
    hosts: []
    pathSuffix: ""
    tls: []
  prePuller:
    annotations: {}
    containerSecurityContext:
      allowPrivilegeEscalation: false
      runAsGroup: 65534
      runAsUser: 65534
    continuous:
      enabled: true
    extraImages: {}
    extraTolerations: []
    hook:
      containerSecurityContext:
        allowPrivilegeEscalation: false
        runAsGroup: 65534
        runAsUser: 65534
      enabled: false
      image:
        name: jupyterhub/k8s-image-awaiter
        pullPolicy: ""
        pullSecrets: []
        tag: 0.11.1
      nodeSelector: {}
      podSchedulingWaitDuration: 10
      resources:
        requests:
          cpu: 0
          memory: 0
      tolerations: []
    pause:
      containerSecurityContext:
        allowPrivilegeEscalation: false
        runAsGroup: 65534
        runAsUser: 65534
      image:
        name: k8s.gcr.io/pause
        pullPolicy: ""
        pullSecrets: []
        tag: "3.2"
    pullProfileListImages: true
    resources:
      requests:
        cpu: 0
        memory: 0
  proxy:
    annotations: {}
    chp:
      containerSecurityContext:
        allowPrivilegeEscalation: false
        runAsGroup: 65534
        runAsUser: 65534
      extraCommandLineFlags: []
      extraEnv: {}
      image:
        name: jupyterhub/configurable-http-proxy
        pullPolicy: ""
        pullSecrets: []
        tag: 4.2.2
      livenessProbe:
        enabled: true
        initialDelaySeconds: 60
        periodSeconds: 10
      networkPolicy:
        allowedIngressPorts:
        - http
        - https
        egress:
        - to:
          - ipBlock:
              cidr: 0.0.0.0/0
        enabled: true
        ingress: []
        interNamespaceAccessLabels: ignore
      nodeSelector: {}
      pdb:
        enabled: false
        minAvailable: 1
      readinessProbe:
        enabled: true
        failureThreshold: 1000
        initialDelaySeconds: 0
        periodSeconds: 2
      resources:
        requests:
          cpu: 200m
          memory: 512Mi
      tolerations: []
    db:
      type: sqlite-memory
    deploymentStrategy:
      type: Recreate
    https:
      enabled: false
      hosts: []
      letsencrypt:
        acmeServer: https://acme-v02.api.letsencrypt.org/directory
        contactEmail: ""
      manual: {}
      secret:
        crt: tls.crt
        key: tls.key
        name: ""
      type: letsencrypt
    labels: {}
    secretSync:
      containerSecurityContext:
        allowPrivilegeEscalation: false
        runAsGroup: 65534
        runAsUser: 65534
      image:
        name: jupyterhub/k8s-secret-sync
        pullPolicy: ""
        pullSecrets: []
        tag: 0.11.1
      resources: {}
    secretToken: af83775ec3bfaf0507ce596df51d491e7ed54450adc454038fa7405495465f19
    service:
      annotations: {}
      extraPorts: []
      labels: {}
      loadBalancerIP: null
      loadBalancerSourceRanges: []
      nodePorts: {}
      type: ClusterIP
    traefik:
      containerSecurityContext:
        allowPrivilegeEscalation: false
        runAsGroup: 65534
        runAsUser: 65534
      extraDynamicConfig: {}
      extraEnv: {}
      extraPorts: []
      extraStaticConfig: {}
      extraVolumeMounts: []
      extraVolumes: []
      hsts:
        includeSubdomains: false
        maxAge: 15724800
        preload: false
      image:
        name: traefik
        pullPolicy: ""
        pullSecrets: []
        tag: v2.3.7
      networkPolicy:
        allowedIngressPorts:
        - http
        - https
        egress:
        - to:
          - ipBlock:
              cidr: 0.0.0.0/0
        enabled: true
        ingress: []
        interNamespaceAccessLabels: ignore
      nodeSelector: {}
      pdb:
        enabled: false
        minAvailable: 1
      resources: {}
      tolerations: []
  rbac:
    enabled: true
  scheduling:
    corePods:
      nodeAffinity:
        matchNodePurpose: prefer
    podPriority:
      defaultPriority: 0
      enabled: false
      globalDefault: false
      userPlaceholderPriority: -10
    userPlaceholder:
      containerSecurityContext:
        allowPrivilegeEscalation: false
        runAsGroup: 65534
        runAsUser: 65534
      enabled: true
      replicas: 0
    userPods:
      nodeAffinity:
        matchNodePurpose: prefer
    userScheduler:
      containerSecurityContext:
        allowPrivilegeEscalation: false
        runAsGroup: 65534
        runAsUser: 65534
      enabled: true
      image:
        name: k8s.gcr.io/kube-scheduler
        pullPolicy: ""
        pullSecrets: []
        tag: v1.19.7
      logLevel: 4
      nodeSelector: {}
      pdb:
        enabled: true
        minAvailable: 1
      plugins:
        score:
          disabled:
          - name: SelectorSpread
          - name: TaintToleration
          - name: PodTopologySpread
          - name: NodeResourcesBalancedAllocation
          - name: NodeResourcesLeastAllocated
          - name: NodePreferAvoidPods
          - name: NodeAffinity
          - name: InterPodAffinity
          - name: ImageLocality
          enabled:
          - name: NodePreferAvoidPods
            weight: 161051
          - name: NodeAffinity
            weight: 14631
          - name: InterPodAffinity
            weight: 1331
          - name: NodeResourcesMostAllocated
            weight: 121
          - name: ImageLocality
            weight: 11
      replicas: 2
      resources:
        requests:
          cpu: 50m
          memory: 256Mi
      tolerations: []
  singleuser:
    cloudMetadata:
      blockWithIptables: true
      ip: 169.254.169.254
    cmd: jupyterhub-singleuser
    cpu: {}
    defaultUrl: null
    events: true
    extraAnnotations: {}
    extraContainers: []
    extraEnv: {}
    extraLabels:
      hub.jupyter.org/network-access-hub: "true"
    extraNodeAffinity:
      preferred: []
      required: []
    extraPodAffinity:
      preferred: []
      required: []
    extraPodAntiAffinity:
      preferred: []
      required: []
    extraPodConfig: {}
    extraResource:
      guarantees: {}
      limits: {}
    extraTolerations: []
    fsGid: 100
    image:
      name: jupyterhub/k8s-singleuser-sample
      pullPolicy: ""
      pullSecrets: []
      tag: 0.11.1
    initContainers: []
    lifecycleHooks: {}
    memory:
      guarantee: 1G
    networkPolicy:
      allowedIngressPorts: []
      egress:
      - to:
        - ipBlock:
            cidr: 0.0.0.0/0
            except:
            - 169.254.169.254/32
      enabled: true
      ingress: []
      interNamespaceAccessLabels: ignore
    networkTools:
      image:
        name: jupyterhub/k8s-network-tools
        pullPolicy: ""
        pullSecrets: []
        tag: 0.11.1
    nodeSelector: {}
    podNameTemplate: null
    profileList:
    - default: true
      description: 'To avoid too much bells and whistles: Python.'
      display_name: Minimal environment
    - description: 'If you want the additional bells and whistles: Python, R, and
        Julia.'
      display_name: Datascience environment
      kubespawner_override:
        image: jupyter/datascience-notebook:7d427e7a4dde
    - description: The Jupyter Stacks spark image
      display_name: Spark environment
      kubespawner_override:
        image: jupyter/all-spark-notebook:latest
    - description: TensorFlow Notebook
      display_name: tensorflow environment
      kubespawner_override:
        image: jupyter/tensorflow-notebook:latest
    serviceAccountName: null
    startTimeout: 300
    storage:
      capacity: 5Gi
      dynamic:
        pvcNameTemplate: claim-{username}{servername}
        storageAccessModes:
        - ReadWriteOnce
        volumeNameTemplate: volume-{username}{servername}
      extraLabels: {}
      extraVolumeMounts: []
      extraVolumes: []
      homeMountPath: /home/jovyan
      static:
        subPath: '{username}'
      type: dynamic
    uid: 1000
  traefikIngress:
    enabled: true
    host: jupyterhub.example.cetic.be
    tls: false
kafka:
  advertisedListeners: []
  affinity: {}
  allowEveryoneIfNoAclFound: true
  allowPlaintextListener: true
  args: []
  auth:
    clientProtocol: plaintext
    externalClientProtocol: ""
    interBrokerProtocol: plaintext
    sasl:
      interBrokerMechanism: plain
      jaas:
        clientPasswords: []
        clientUsers:
        - user
        existingSecret: ""
        interBrokerPassword: ""
        interBrokerUser: admin
        zookeeperPassword: ""
        zookeeperUser: ""
      mechanisms: plain,scram-sha-256,scram-sha-512
    tls:
      autoGenerated: false
      endpointIdentificationAlgorithm: https
      existingSecret: ""
      existingSecrets: []
      jksKeystoreSAN: ""
      jksTruststore: ""
      jksTruststoreSecret: ""
      password: ""
      pemChainIncluded: false
      type: jks
    zookeeper:
      tls:
        enabled: false
        existingSecret: ""
        existingSecretKeystoreKey: zookeeper.keystore.jks
        existingSecretTruststoreKey: zookeeper.truststore.jks
        passwordsSecret: ""
        passwordsSecretKeystoreKey: keystore-password
        passwordsSecretTruststoreKey: truststore-password
        type: jks
        verifyHostname: true
  authorizerClassName: ""
  autoCreateTopicsEnable: true
  clusterDomain: cluster.local
  command:
  - /scripts/setup.sh
  common:
    exampleValue: common-chart
    global:
      imagePullSecrets: []
      imageRegistry: ""
      storageClass: ""
  commonAnnotations: {}
  commonLabels: {}
  config: ""
  containerPorts:
    client: 9092
    external: 9094
    internal: 9093
  containerSecurityContext:
    enabled: true
    runAsNonRoot: true
    runAsUser: 1001
  customLivenessProbe: {}
  customReadinessProbe: {}
  customStartupProbe: {}
  defaultReplicationFactor: 1
  deleteTopicEnable: false
  diagnosticMode:
    args:
    - infinity
    command:
    - sleep
    enabled: false
  enabled: false
  existingConfigmap: ""
  existingLog4jConfigMap: ""
  external:
    enabled: false
  externalAccess:
    autoDiscovery:
      enabled: false
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/kubectl
        tag: 1.24.0-debian-10-r2
      resources:
        limits: {}
        requests: {}
    enabled: false
    service:
      annotations: {}
      domain: ""
      extraPorts: []
      loadBalancerAnnotations: []
      loadBalancerIPs: []
      loadBalancerNames: []
      loadBalancerSourceRanges: []
      nodePorts: []
      ports:
        external: 9094
      type: LoadBalancer
      useHostIPs: false
      usePodIPs: false
  externalZookeeper:
    servers: []
  extraDeploy: []
  extraEnvVars: []
  extraEnvVarsCM: ""
  extraEnvVarsSecret: ""
  extraVolumeMounts: []
  extraVolumes: []
  fullnameOverride: ""
  global:
    imagePullSecrets: []
    imageRegistry: ""
    storageClass: ""
  heapOpts: -Xmx1024m -Xms1024m
  hostAliases: []
  hostIPC: false
  hostNetwork: false
  image:
    debug: false
    pullPolicy: IfNotPresent
    pullSecrets: []
    registry: docker.io
    repository: bitnami/kafka
    tag: 3.1.1-debian-10-r6
  initContainers: []
  interBrokerListenerName: INTERNAL
  kubeVersion: ""
  lifecycleHooks: {}
  listenerSecurityProtocolMap: ""
  listeners: []
  livenessProbe:
    enabled: true
    failureThreshold: 3
    initialDelaySeconds: 10
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 5
  log4j: ""
  logFlushIntervalMessages: _10000
  logFlushIntervalMs: 1000
  logPersistence:
    accessModes:
    - ReadWriteOnce
    annotations: {}
    enabled: false
    existingClaim: ""
    mountPath: /opt/bitnami/kafka/logs
    selector: {}
    size: 8Gi
    storageClass: ""
  logRetentionBytes: _1073741824
  logRetentionCheckIntervalMs: 300000
  logRetentionHours: 168
  logSegmentBytes: _1073741824
  logsDirs: /bitnami/kafka/data
  maxMessageBytes: _1000012
  metrics:
    jmx:
      config: |-
        jmxUrl: service:jmx:rmi:///jndi/rmi://127.0.0.1:5555/jmxrmi
        lowercaseOutputName: true
        lowercaseOutputLabelNames: true
        ssl: false
        {{- if .Values.metrics.jmx.whitelistObjectNames }}
        whitelistObjectNames: ["{{ join "\",\"" .Values.metrics.jmx.whitelistObjectNames }}"]
        {{- end }}
      containerPorts:
        metrics: 5556
      containerSecurityContext:
        enabled: true
        runAsNonRoot: true
        runAsUser: 1001
      enabled: false
      existingConfigmap: ""
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/jmx-exporter
        tag: 0.16.1-debian-10-r303
      resources:
        limits: {}
        requests: {}
      service:
        annotations:
          prometheus.io/path: /
          prometheus.io/port: '{{ .Values.metrics.jmx.service.ports.metrics }}'
          prometheus.io/scrape: "true"
        clusterIP: ""
        ports:
          metrics: 5556
        sessionAffinity: None
      whitelistObjectNames:
      - kafka.controller:*
      - kafka.server:*
      - java.lang:*
      - kafka.network:*
      - kafka.log:*
    kafka:
      affinity: {}
      args: []
      certificatesSecret: ""
      command: []
      containerPorts:
        metrics: 9308
      containerSecurityContext:
        enabled: true
        runAsNonRoot: true
        runAsUser: 1001
      enabled: false
      extraFlags: {}
      extraVolumeMounts: []
      extraVolumes: []
      hostAliases: []
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/kafka-exporter
        tag: 1.4.2-debian-10-r240
      initContainers: []
      nodeAffinityPreset:
        key: ""
        type: ""
        values: []
      nodeSelector: {}
      podAffinityPreset: ""
      podAnnotations: {}
      podAntiAffinityPreset: soft
      podLabels: {}
      podSecurityContext:
        enabled: true
        fsGroup: 1001
      resources:
        limits: {}
        requests: {}
      schedulerName: ""
      service:
        annotations:
          prometheus.io/path: /metrics
          prometheus.io/port: '{{ .Values.metrics.kafka.service.ports.metrics }}'
          prometheus.io/scrape: "true"
        clusterIP: ""
        ports:
          metrics: 9308
        sessionAffinity: None
      serviceAccount:
        automountServiceAccountToken: true
        create: true
        name: ""
      sidecars: []
      tlsCaCert: ca-file
      tlsCaSecret: ""
      tlsCert: cert-file
      tlsKey: key-file
      tolerations: []
    serviceMonitor:
      enabled: false
      honorLabels: false
      interval: ""
      jobLabel: ""
      labels: {}
      metricRelabelings: []
      namespace: ""
      relabelings: []
      scrapeTimeout: ""
      selector: {}
  minBrokerId: 0
  nameOverride: ""
  networkPolicy:
    allowExternal: true
    egressRules:
      customRules: []
    enabled: false
    explicitNamespacesSelector: {}
    externalAccess:
      from: []
  nodeAffinityPreset:
    key: ""
    type: ""
    values: []
  nodeSelector: {}
  numIoThreads: 8
  numNetworkThreads: 3
  numPartitions: 1
  numRecoveryThreadsPerDataDir: 1
  offsetsTopicReplicationFactor: 1
  pdb:
    create: false
    maxUnavailable: 1
    minAvailable: ""
  persistence:
    accessModes:
    - ReadWriteOnce
    annotations: {}
    enabled: true
    existingClaim: ""
    mountPath: /bitnami/kafka
    selector: {}
    size: 8Gi
    storageClass: ""
  podAffinityPreset: ""
  podAnnotations: {}
  podAntiAffinityPreset: soft
  podLabels: {}
  podManagementPolicy: Parallel
  podSecurityContext:
    enabled: true
    fsGroup: 1001
  priorityClassName: ""
  provisioning:
    args: []
    auth:
      tls:
        caCert: ca.crt
        cert: tls.crt
        certificatesSecret: ""
        key: tls.key
        keyPassword: ""
        keyPasswordSecretKey: key-password
        keystore: keystore.jks
        keystorePassword: ""
        keystorePasswordSecretKey: keystore-password
        passwordsSecret: ""
        truststore: truststore.jks
        truststorePassword: ""
        truststorePasswordSecretKey: truststore-password
        type: jks
    command: []
    containerSecurityContext:
      enabled: true
      runAsNonRoot: true
      runAsUser: 1001
    enabled: false
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraProvisioningCommands: []
    extraVolumeMounts: []
    extraVolumes: []
    initContainers: []
    numPartitions: 1
    parallel: 1
    podAnnotations: {}
    podLabels: {}
    podSecurityContext:
      enabled: true
      fsGroup: 1001
    postScript: ""
    preScript: ""
    replicationFactor: 1
    resources:
      limits: {}
      requests: {}
    schedulerName: ""
    sidecars: []
    topics: []
    waitForKafka: true
  rbac:
    create: false
  readinessProbe:
    enabled: true
    failureThreshold: 6
    initialDelaySeconds: 5
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 5
  replicaCount: 1
  replicas: 1
  resources:
    limits: {}
    requests: {}
  schedulerName: ""
  service:
    annotations: {}
    clusterIP: ""
    externalTrafficPolicy: Cluster
    extraPorts: []
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    nodePorts:
      client: ""
      external: ""
    ports:
      client: 9092
      external: 9094
      internal: 9093
    sessionAffinity: None
    type: ClusterIP
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: true
    create: true
    name: ""
  sidecars: []
  socketReceiveBufferBytes: 102400
  socketRequestMaxBytes: _104857600
  socketSendBufferBytes: 102400
  startupProbe:
    enabled: false
    failureThreshold: 15
    initialDelaySeconds: 30
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1
  superUsers: User:admin
  terminationGracePeriodSeconds: ""
  tolerations: []
  topologySpreadConstraints: {}
  transactionStateLogMinIsr: 1
  transactionStateLogReplicationFactor: 1
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
  volumePermissions:
    containerSecurityContext:
      runAsUser: 0
    enabled: false
    image:
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/bitnami-shell
      tag: 10-debian-10-r431
    resources:
      limits: {}
      requests: {}
  zookeeper:
    affinity: {}
    args: []
    auth:
      clientPassword: ""
      clientUser: ""
      enabled: false
      existingSecret: ""
      serverPasswords: ""
      serverUsers: ""
    autopurge:
      purgeInterval: 0
      snapRetainCount: 3
    clusterDomain: cluster.local
    command:
    - /scripts/setup.sh
    common:
      exampleValue: common-chart
      global:
        imagePullSecrets: []
        imageRegistry: ""
        storageClass: ""
    commonAnnotations: {}
    commonLabels: {}
    configuration: ""
    containerPorts:
      client: 2181
      election: 3888
      follower: 2888
      tls: 3181
    containerSecurityContext:
      enabled: true
      runAsNonRoot: true
      runAsUser: 1001
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    dataLogDir: ""
    diagnosticMode:
      args:
      - infinity
      command:
      - sleep
      enabled: false
    enabled: true
    existingConfigmap: ""
    extraDeploy: []
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraVolumeMounts: []
    extraVolumes: []
    fourlwCommandsWhitelist: srvr, mntr, ruok
    fullnameOverride: fadi-kafka-zookeeper
    global:
      imagePullSecrets: []
      imageRegistry: ""
      storageClass: ""
    heapSize: 1024
    hostAliases: []
    image:
      debug: false
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/zookeeper
      tag: 3.8.0-debian-10-r63
    initContainers: []
    initLimit: 10
    jvmFlags: ""
    kubeVersion: ""
    lifecycleHooks: {}
    listenOnAllIPs: false
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      probeCommandTimeout: 2
      successThreshold: 1
      timeoutSeconds: 5
    logLevel: ERROR
    maxClientCnxns: 60
    maxSessionTimeout: 40000
    metrics:
      containerPort: 9141
      enabled: false
      prometheusRule:
        additionalLabels: {}
        enabled: false
        namespace: ""
        rules: []
      service:
        annotations:
          prometheus.io/path: /metrics
          prometheus.io/port: '{{ .Values.metrics.service.port }}'
          prometheus.io/scrape: "true"
        port: 9141
        type: ClusterIP
      serviceMonitor:
        additionalLabels: {}
        enabled: false
        honorLabels: false
        interval: ""
        jobLabel: ""
        metricRelabelings: []
        namespace: ""
        relabelings: []
        scrapeTimeout: ""
        selector: {}
    minServerId: 1
    nameOverride: ""
    namespaceOverride: ""
    networkPolicy:
      allowExternal: true
      enabled: false
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    pdb:
      create: false
      maxUnavailable: 1
      minAvailable: ""
    persistence:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      dataLogDir:
        existingClaim: ""
        selector: {}
        size: 8Gi
      enabled: true
      existingClaim: ""
      selector: {}
      size: 8Gi
      storageClass: ""
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podManagementPolicy: Parallel
    podSecurityContext:
      enabled: true
      fsGroup: 1001
    preAllocSize: 65536
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      probeCommandTimeout: 2
      successThreshold: 1
      timeoutSeconds: 5
    replicaCount: 1
    resources:
      limits: {}
      requests:
        cpu: 250m
        memory: 256Mi
    schedulerName: ""
    service:
      annotations: {}
      clusterIP: ""
      disableBaseClientPort: false
      externalTrafficPolicy: Cluster
      extraPorts: []
      headless:
        annotations: {}
        publishNotReadyAddresses: true
      loadBalancerIP: ""
      loadBalancerSourceRanges: []
      nodePorts:
        client: ""
        tls: ""
      ports:
        client: 2181
        election: 3888
        follower: 2888
        tls: 3181
      sessionAffinity: None
      type: ClusterIP
    serviceAccount:
      annotations: {}
      automountServiceAccountToken: true
      create: false
      name: ""
    sidecars: []
    snapCount: 100000
    startupProbe:
      enabled: false
      failureThreshold: 15
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1
    syncLimit: 5
    tickTime: 2000
    tls:
      client:
        auth: none
        autoGenerated: false
        enabled: false
        existingSecret: ""
        existingSecretKeystoreKey: ""
        existingSecretTruststoreKey: ""
        keystorePassword: ""
        keystorePath: /opt/bitnami/zookeeper/config/certs/client/zookeeper.keystore.jks
        passwordsSecretKeystoreKey: ""
        passwordsSecretName: ""
        passwordsSecretTruststoreKey: ""
        truststorePassword: ""
        truststorePath: /opt/bitnami/zookeeper/config/certs/client/zookeeper.truststore.jks
      quorum:
        auth: none
        autoGenerated: false
        enabled: false
        existingSecret: ""
        existingSecretKeystoreKey: ""
        existingSecretTruststoreKey: ""
        keystorePassword: ""
        keystorePath: /opt/bitnami/zookeeper/config/certs/quorum/zookeeper.keystore.jks
        passwordsSecretKeystoreKey: ""
        passwordsSecretName: ""
        passwordsSecretTruststoreKey: ""
        truststorePassword: ""
        truststorePath: /opt/bitnami/zookeeper/config/certs/quorum/zookeeper.truststore.jks
      resources:
        limits: {}
        requests: {}
    tolerations: []
    topologySpreadConstraints: {}
    updateStrategy:
      rollingUpdate: {}
      type: RollingUpdate
    volumePermissions:
      containerSecurityContext:
        runAsUser: 0
      enabled: false
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/bitnami-shell
        tag: 10-debian-10-r430
      resources:
        limits: {}
        requests: {}
  zookeeperChrootPath: ""
  zookeeperConnectionTimeoutMs: 6000
keycloak:
  affinity: {}
  args: []
  auth:
    adminPassword: password1
    adminUser: admin
    createAdminUser: true
    existingSecret: ""
    existingSecretPerPassword: {}
    managementPassword: password2
    managementUser: manager
    tls:
      autoGenerated: false
      enabled: false
      existingSecret: ""
      jksSecret: ""
      keystoreFilename: ""
      keystorePassword: ""
      resources:
        limits: {}
        requests: {}
      truststoreFilename: ""
      truststorePassword: ""
      usePem: false
  autoscaling:
    enabled: false
    maxReplicas: 11
    minReplicas: 1
    targetCPU: ""
    targetMemory: ""
  cache:
    enabled: false
  clusterDomain: cluster.local
  command: []
  common:
    exampleValue: common-chart
    global:
      imagePullSecrets: []
      imageRegistry: ""
      storageClass: ""
  commonAnnotations: {}
  commonLabels: {}
  configuration: ""
  containerPorts:
    http: 8080
    https: 8443
  containerSecurityContext:
    enabled: true
    runAsNonRoot: true
    runAsUser: 1001
  customLivenessProbe: {}
  customReadinessProbe: {}
  customStartupProbe: {}
  diagnosticMode:
    args:
    - infinity
    command:
    - sleep
    enabled: false
  enabled: true
  existingConfigmap: ""
  externalDatabase:
    database: postgres
    existingSecret: ""
    existingSecretPasswordKey: ""
    host: fadi-postgresql
    password: Z2JHHezi4aAA
    port: 5432
    user: admin
  extraDeploy: []
  extraEnvVars: []
  extraEnvVarsCM: ""
  extraEnvVarsSecret: ""
  extraStartupArgs: ""
  extraVolumeMounts: []
  extraVolumes: []
  fullnameOverride: ""
  global:
    imagePullSecrets: []
    imageRegistry: ""
    storageClass: ""
  hostAliases: []
  httpRelativePath: /
  image:
    debug: false
    digest: ""
    pullPolicy: IfNotPresent
    pullSecrets: []
    registry: docker.io
    repository: bitnami/keycloak
    tag: 19.0.3-debian-11-r4
  ingress:
    annotations: {}
    apiVersion: ""
    enabled: false
    extraHosts: []
    extraPaths: []
    extraRules: []
    extraTls: []
    hostname: keycloak.local
    ingressClassName: ""
    path: /
    pathType: ImplementationSpecific
    secrets: []
    selfSigned: false
    servicePort: http
    tls: false
  initContainers: []
  initdbScripts: {}
  initdbScriptsConfigMap: ""
  keycloakConfigCli:
    annotations:
      helm.sh/hook: post-install,post-upgrade,post-rollback
      helm.sh/hook-delete-policy: hook-succeeded,before-hook-creation
      helm.sh/hook-weight: "5"
    args: []
    backoffLimit: 1
    command: []
    configuration: {}
    containerSecurityContext:
      enabled: true
      runAsNonRoot: true
      runAsUser: 1001
    enabled: false
    existingConfigmap: ""
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraVolumeMounts: []
    extraVolumes: []
    hostAliases: []
    image:
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/keycloak-config-cli
      tag: 5.3.1-debian-11-r28
    initContainers: []
    podAnnotations: {}
    podLabels: {}
    podSecurityContext:
      enabled: true
      fsGroup: 1001
    podTolerations: []
    resources:
      limits: {}
      requests: {}
    sidecars: []
  kubeVersion: ""
  lifecycleHooks: {}
  livenessProbe:
    enabled: true
    failureThreshold: 3
    initialDelaySeconds: 300
    periodSeconds: 1
    successThreshold: 1
    timeoutSeconds: 5
  logging:
    output: default
  metrics:
    enabled: false
    prometheusRule:
      enabled: false
      groups: []
      labels: {}
      namespace: ""
    service:
      annotations:
        prometheus.io/port: '{{ .Values.metrics.service.ports.http }}'
        prometheus.io/scrape: "true"
      ports:
        http: 8080
    serviceMonitor:
      enabled: false
      endpoints:
      - path: /metrics
      - path: /realms/master/metrics
      honorLabels: false
      interval: 30s
      jobLabel: ""
      labels: {}
      metricRelabelings: []
      namespace: ""
      path: ""
      port: http
      relabelings: []
      scrapeTimeout: ""
      selector: {}
  nameOverride: ""
  namespaceOverride: ""
  networkPolicy:
    additionalRules: {}
    allowExternal: true
    enabled: false
  nodeAffinityPreset:
    key: ""
    type: ""
    values: []
  nodeSelector: {}
  pdb:
    create: false
    maxUnavailable: ""
    minAvailable: 1
  podAffinityPreset: ""
  podAnnotations: {}
  podAntiAffinityPreset: soft
  podLabels: {}
  podManagementPolicy: Parallel
  podSecurityContext:
    enabled: true
    fsGroup: 1001
  postgresql:
    architecture: standalone
    audit:
      clientMinMessages: error
      logConnections: false
      logDisconnections: false
      logHostname: false
      logLinePrefix: ""
      logTimezone: ""
      pgAuditLog: ""
      pgAuditLogCatalog: "off"
    auth:
      database: bitnami_keycloak
      enablePostgresUser: true
      existingSecret: ""
      password: ""
      postgresPassword: ""
      replicationPassword: ""
      replicationUsername: repl_user
      secretKeys:
        adminPasswordKey: postgres-password
        replicationPasswordKey: replication-password
        userPasswordKey: password
      usePasswordFiles: false
      username: bn_keycloak
    clusterDomain: cluster.local
    common:
      exampleValue: common-chart
      global:
        imagePullSecrets: []
        imageRegistry: ""
        postgresql:
          auth:
            database: ""
            existingSecret: ""
            password: ""
            postgresPassword: ""
            secretKeys:
              adminPasswordKey: ""
              replicationPasswordKey: ""
              userPasswordKey: ""
            username: ""
          service:
            ports:
              postgresql: ""
        storageClass: ""
    commonAnnotations: {}
    commonLabels: {}
    containerPorts:
      postgresql: 5432
    diagnosticMode:
      args:
      - infinity
      command:
      - sleep
      enabled: false
    enabled: false
    extraDeploy: []
    fullnameOverride: ""
    global:
      imagePullSecrets: []
      imageRegistry: ""
      postgresql:
        auth:
          database: ""
          existingSecret: ""
          password: ""
          postgresPassword: ""
          secretKeys:
            adminPasswordKey: ""
            replicationPasswordKey: ""
            userPasswordKey: ""
          username: ""
        service:
          ports:
            postgresql: ""
      storageClass: ""
    image:
      debug: false
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/postgresql
      tag: 14.5.0-debian-11-r34
    kubeVersion: ""
    ldap:
      basedn: ""
      binddn: ""
      bindpw: ""
      enabled: false
      port: ""
      prefix: ""
      scheme: ""
      searchAttribute: ""
      searchFilter: ""
      server: ""
      suffix: ""
      tls:
        enabled: false
      uri: ""
    metrics:
      containerPorts:
        metrics: 9187
      containerSecurityContext:
        enabled: true
        runAsNonRoot: true
        runAsUser: 1001
      customLivenessProbe: {}
      customMetrics: {}
      customReadinessProbe: {}
      customStartupProbe: {}
      enabled: false
      extraEnvVars: []
      image:
        digest: ""
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/postgres-exporter
        tag: 0.11.1-debian-11-r22
      livenessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      prometheusRule:
        enabled: false
        labels: {}
        namespace: ""
        rules: []
      readinessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      resources:
        limits: {}
        requests: {}
      service:
        annotations:
          prometheus.io/port: '{{ .Values.metrics.service.ports.metrics }}'
          prometheus.io/scrape: "true"
        clusterIP: ""
        ports:
          metrics: 9187
        sessionAffinity: None
      serviceMonitor:
        enabled: false
        honorLabels: false
        interval: ""
        jobLabel: ""
        labels: {}
        metricRelabelings: []
        namespace: ""
        relabelings: []
        scrapeTimeout: ""
        selector: {}
      startupProbe:
        enabled: false
        failureThreshold: 15
        initialDelaySeconds: 10
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 1
    nameOverride: ""
    networkPolicy:
      egressRules:
        customRules: {}
        denyConnectionsToExternal: false
      enabled: false
      ingressRules:
        primaryAccessOnlyFrom:
          customRules: {}
          enabled: false
          namespaceSelector: {}
          podSelector: {}
        readReplicasAccessOnlyFrom:
          customRules: {}
          enabled: false
          namespaceSelector: {}
          podSelector: {}
      metrics:
        enabled: false
        namespaceSelector: {}
        podSelector: {}
    postgresqlDataDir: /bitnami/postgresql/data
    postgresqlSharedPreloadLibraries: pgaudit
    primary:
      affinity: {}
      annotations: {}
      args: []
      command: []
      configuration: ""
      containerSecurityContext:
        enabled: true
        runAsUser: 1001
      customLivenessProbe: {}
      customReadinessProbe: {}
      customStartupProbe: {}
      existingConfigmap: ""
      existingExtendedConfigmap: ""
      extendedConfiguration: ""
      extraEnvVars: []
      extraEnvVarsCM: ""
      extraEnvVarsSecret: ""
      extraPodSpec: {}
      extraVolumeMounts: []
      extraVolumes: []
      hostAliases: []
      hostIPC: false
      hostNetwork: false
      initContainers: []
      initdb:
        args: ""
        password: ""
        postgresqlWalDir: ""
        scripts: {}
        scriptsConfigMap: ""
        scriptsSecret: ""
        user: ""
      labels: {}
      lifecycleHooks: {}
      livenessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 30
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      name: primary
      nodeAffinityPreset:
        key: ""
        type: ""
        values: []
      nodeSelector: {}
      persistence:
        accessModes:
        - ReadWriteOnce
        annotations: {}
        dataSource: {}
        enabled: true
        existingClaim: ""
        labels: {}
        mountPath: /bitnami/postgresql
        selector: {}
        size: 8Gi
        storageClass: ""
        subPath: ""
      pgHbaConfiguration: ""
      podAffinityPreset: ""
      podAnnotations: {}
      podAntiAffinityPreset: soft
      podLabels: {}
      podSecurityContext:
        enabled: true
        fsGroup: 1001
      priorityClassName: ""
      readinessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      resources:
        limits: {}
        requests:
          cpu: 250m
          memory: 256Mi
      schedulerName: ""
      service:
        annotations: {}
        clusterIP: ""
        externalTrafficPolicy: Cluster
        extraPorts: []
        loadBalancerIP: ""
        loadBalancerSourceRanges: []
        nodePorts:
          postgresql: ""
        ports:
          postgresql: 5432
        sessionAffinity: None
        sessionAffinityConfig: {}
        type: ClusterIP
      sidecars: []
      standby:
        enabled: false
        primaryHost: ""
        primaryPort: ""
      startupProbe:
        enabled: false
        failureThreshold: 15
        initialDelaySeconds: 30
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 1
      terminationGracePeriodSeconds: ""
      tolerations: []
      topologySpreadConstraints: []
      updateStrategy:
        rollingUpdate: {}
        type: RollingUpdate
    psp:
      create: false
    rbac:
      create: false
      rules: []
    readReplicas:
      affinity: {}
      annotations: {}
      args: []
      command: []
      containerSecurityContext:
        enabled: true
        runAsUser: 1001
      customLivenessProbe: {}
      customReadinessProbe: {}
      customStartupProbe: {}
      extendedConfiguration: ""
      extraEnvVars: []
      extraEnvVarsCM: ""
      extraEnvVarsSecret: ""
      extraPodSpec: {}
      extraVolumeMounts: []
      extraVolumes: []
      hostAliases: []
      hostIPC: false
      hostNetwork: false
      initContainers: []
      labels: {}
      lifecycleHooks: {}
      livenessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 30
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      name: read
      nodeAffinityPreset:
        key: ""
        type: ""
        values: []
      nodeSelector: {}
      persistence:
        accessModes:
        - ReadWriteOnce
        annotations: {}
        dataSource: {}
        enabled: true
        existingClaim: ""
        labels: {}
        mountPath: /bitnami/postgresql
        selector: {}
        size: 8Gi
        storageClass: ""
        subPath: ""
      podAffinityPreset: ""
      podAnnotations: {}
      podAntiAffinityPreset: soft
      podLabels: {}
      podSecurityContext:
        enabled: true
        fsGroup: 1001
      priorityClassName: ""
      readinessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      replicaCount: 1
      resources:
        limits: {}
        requests:
          cpu: 250m
          memory: 256Mi
      schedulerName: ""
      service:
        annotations: {}
        clusterIP: ""
        externalTrafficPolicy: Cluster
        extraPorts: []
        loadBalancerIP: ""
        loadBalancerSourceRanges: []
        nodePorts:
          postgresql: ""
        ports:
          postgresql: 5432
        sessionAffinity: None
        sessionAffinityConfig: {}
        type: ClusterIP
      sidecars: []
      startupProbe:
        enabled: false
        failureThreshold: 15
        initialDelaySeconds: 30
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 1
      terminationGracePeriodSeconds: ""
      tolerations: []
      topologySpreadConstraints: []
      updateStrategy:
        rollingUpdate: {}
        type: RollingUpdate
    replication:
      applicationName: my_application
      numSynchronousReplicas: 0
      synchronousCommit: "off"
    serviceAccount:
      annotations: {}
      automountServiceAccountToken: true
      create: false
      name: ""
    shmVolume:
      enabled: true
      sizeLimit: ""
    tls:
      autoGenerated: false
      certCAFilename: ""
      certFilename: ""
      certKeyFilename: ""
      certificatesSecret: ""
      crlFilename: ""
      enabled: false
      preferServerCiphers: true
    volumePermissions:
      containerSecurityContext:
        runAsUser: 0
      enabled: false
      image:
        digest: ""
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/bitnami-shell
        tag: 11-debian-11-r45
      resources:
        limits: {}
        requests: {}
  priorityClassName: ""
  proxy: passthrough
  rbac:
    create: false
    rules: []
  readinessProbe:
    enabled: true
    failureThreshold: 3
    initialDelaySeconds: 30
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1
  replicaCount: 1
  resources:
    limits: {}
    requests: {}
  schedulerName: ""
  service:
    annotations: {}
    clusterIP: ""
    externalTrafficPolicy: Cluster
    extraPorts: []
    http:
      enabled: true
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    nodePorts:
      http: ""
      https: ""
    ports:
      http: 80
      https: 443
    sessionAffinity: None
    sessionAffinityConfig: {}
    type: ClusterIP
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: true
    create: true
    name: ""
  sidecars: []
  startupProbe:
    enabled: false
    failureThreshold: 60
    initialDelaySeconds: 30
    periodSeconds: 5
    successThreshold: 1
    timeoutSeconds: 1
  terminationGracePeriodSeconds: ""
  tolerations: []
  topologySpreadConstraints: []
  traefikIngress:
    enabled: true
    host: keycloak.example.cetic.be
    tls: false
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
kibana:
  affinity: {}
  annotations: {}
  automountToken: true
  elasticsearchHosts: http://elasticsearch-master:9200
  elasticsearchURL: ""
  enabled: false
  env:
    ELASTICSEARCH_HOSTS: http://{{ .Release.Name }}-elasticsearch-client:9200
  envFrom: []
  extraContainers: []
  extraEnvs:
  - name: NODE_OPTIONS
    value: --max-old-space-size=1800
  extraInitContainers: []
  extraVolumeMounts: []
  extraVolumes: []
  fullnameOverride: ""
  global: {}
  healthCheckPath: /app/kibana
  hostAliases: []
  httpPort: 5601
  image: docker.elastic.co/kibana/kibana
  imagePullPolicy: IfNotPresent
  imagePullSecrets: []
  imageTag: 7.17.3
  ingress:
    annotations: {}
    className: nginx
    enabled: false
    hosts:
    - host: kibana-example.local
      paths:
      - path: /
    pathtype: ImplementationSpecific
  kibanaConfig: {}
  labels: {}
  lifecycle: {}
  nameOverride: ""
  nodeSelector: {}
  podAnnotations: {}
  podSecurityContext:
    fsGroup: 1000
  priorityClassName: ""
  protocol: http
  readinessProbe:
    failureThreshold: 3
    initialDelaySeconds: 10
    periodSeconds: 10
    successThreshold: 3
    timeoutSeconds: 5
  replicas: 1
  resources:
    limits:
      cpu: 1000m
      memory: 2Gi
    requests:
      cpu: 1000m
      memory: 2Gi
  secretMounts: []
  securityContext:
    capabilities:
      drop:
      - ALL
    runAsNonRoot: true
    runAsUser: 1000
  serverHost: 0.0.0.0
  service:
    annotations: {}
    httpPortName: http
    labels: {}
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    nodePort: ""
    port: 5601
    type: ClusterIP
  serviceAccount: ""
  tolerations: []
  updateStrategy:
    type: Recreate
logstash:
  antiAffinity: hard
  antiAffinityTopologyKey: kubernetes.io/hostname
  elasticsearch:
    host: fadi-elasticsearch-client
  enabled: false
  envFrom: []
  extraContainers: []
  extraEnvs: []
  extraInitContainers: []
  extraPorts: []
  extraVolumeMounts: []
  extraVolumes: []
  fullnameOverride: ""
  global: {}
  hostAliases: []
  httpPort: 9600
  image: docker.elastic.co/logstash/logstash
  imagePullPolicy: IfNotPresent
  imagePullSecrets: []
  imageTag: 7.17.3
  ingress:
    annotations: {}
    className: nginx
    enabled: false
    hosts:
    - host: logstash-example.local
      paths:
      - path: /beats
        servicePort: 5044
      - path: /http
        servicePort: 8080
    pathtype: ImplementationSpecific
    tls: []
  labels: {}
  lifecycle: {}
  livenessProbe:
    failureThreshold: 3
    httpGet:
      path: /
      port: http
    initialDelaySeconds: 300
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 5
  logstashConfig: {}
  logstashJavaOpts: -Xmx1g -Xms1g
  logstashPattern: {}
  logstashPatternDir: /usr/share/logstash/patterns/
  logstashPipeline: {}
  maxUnavailable: 1
  nameOverride: ""
  nodeAffinity: {}
  nodeSelector: {}
  persistence:
    annotations: {}
    enabled: false
  podAffinity: {}
  podAnnotations: {}
  podManagementPolicy: Parallel
  podSecurityContext:
    fsGroup: 1000
    runAsUser: 1000
  podSecurityPolicy:
    create: false
    name: ""
    spec:
      fsGroup:
        rule: RunAsAny
      privileged: false
      runAsUser:
        rule: RunAsAny
      seLinux:
        rule: RunAsAny
      supplementalGroups:
        rule: RunAsAny
      volumes:
      - secret
      - configMap
      - persistentVolumeClaim
  priorityClassName: ""
  rbac:
    annotations: {}
    create: false
    serviceAccountAnnotations: {}
    serviceAccountName: ""
  readinessProbe:
    failureThreshold: 3
    httpGet:
      path: /
      port: http
    initialDelaySeconds: 60
    periodSeconds: 10
    successThreshold: 3
    timeoutSeconds: 5
  replicas: 1
  resources:
    limits:
      cpu: 1000m
      memory: 1536Mi
    requests:
      cpu: 100m
      memory: 1536Mi
  schedulerName: ""
  secretMounts: []
  secrets: []
  securityContext:
    capabilities:
      drop:
      - ALL
    runAsNonRoot: true
    runAsUser: 1000
  service: {}
  terminationGracePeriod: 120
  tolerations: []
  updateStrategy: RollingUpdate
  volumeClaimTemplate:
    accessModes:
    - ReadWriteOnce
    resources:
      requests:
        storage: 1Gi
minio:
  DeploymentUpdate:
    maxSurge: 100%
    maxUnavailable: 0
    type: RollingUpdate
  StatefulSetUpdate:
    updateStrategy: RollingUpdate
  accessKey: TShGemD0Ix
  additionalAnnotations: []
  additionalLabels: []
  affinity: {}
  azuregateway:
    enabled: false
    replicas: 4
  bucketRoot: ""
  buckets: []
  certsPath: /etc/minio/certs/
  clusterDomain: cluster.local
  configPathmc: /etc/minio/mc/
  defaultBucket:
    enabled: false
    name: bucket
    policy: none
    purge: false
  drivesPerNode: 1
  enabled: true
  environment: {}
  etcd:
    clientCert: ""
    clientCertKey: ""
    corednsPathPrefix: ""
    endpoints: []
    pathPrefix: ""
  existingSecret: ""
  extraArgs: []
  fullnameOverride: ""
  gcsgateway:
    enabled: false
    gcsKeyJson: ""
    projectId: ""
    replicas: 4
  global: {}
  helmKubectlJqImage:
    pullPolicy: IfNotPresent
    repository: bskim45/helm-kubectl-jq
    tag: 3.1.0
  image:
    pullPolicy: IfNotPresent
    repository: minio/minio
    tag: RELEASE.2021-02-14T04-01-33Z
  imagePullSecrets: []
  ingress:
    annotations: {}
    enabled: false
    hosts:
    - chart-example.local
    labels: {}
    path: /
    tls: []
  makeBucketJob:
    resources:
      requests:
        memory: 128Mi
    securityContext:
      enabled: false
      fsGroup: 1000
      runAsGroup: 1000
      runAsUser: 1000
  mcImage:
    pullPolicy: IfNotPresent
    repository: minio/mc
    tag: RELEASE.2021-02-14T04-28-06Z
  metrics:
    serviceMonitor:
      additionalLabels: {}
      enabled: false
      relabelConfigs: {}
  mode: standalone
  mountPath: /export
  nameOverride: ""
  nasgateway:
    enabled: false
    replicas: 4
  networkPolicy:
    allowExternal: true
    enabled: false
  nodeSelector: {}
  persistence:
    VolumeName: ""
    accessMode: ReadWriteOnce
    enabled: true
    existingClaim: ""
    size: 50Gi
    storageClass: ""
    subPath: ""
  podAnnotations: {}
  podDisruptionBudget:
    enabled: false
    maxUnavailable: 1
  podLabels: {}
  priorityClassName: ""
  replicas: 4
  resources:
    requests:
      memory: 4Gi
  s3gateway:
    accessKey: ""
    enabled: false
    replicas: 4
    secretKey: ""
    serviceEndpoint: ""
  secretKey: LcCbxVDXlD
  securityContext:
    enabled: true
    fsGroup: 1000
    runAsGroup: 1000
    runAsUser: 1000
  service:
    annotations: {}
    clusterIP: null
    externalIPs: []
    nodePort: 32000
    port: 9000
    type: ClusterIP
  serviceAccount:
    create: true
  tls:
    certSecret: ""
    enabled: false
    privateKey: private.key
    publicCrt: public.crt
  tolerations: []
  trustedCertsSecret: ""
  updatePrometheusJob:
    securityContext:
      enabled: false
      fsGroup: 1000
      runAsGroup: 1000
      runAsUser: 1000
  zones: 1
mlflow:
  affinity: {}
  db:
    database: postgres
    default:
      enabled: false
    host: fadi-postgresql
    password: password1
    port: 5432
    type: postgresql
    user: admin
  default_artifact_root: s3://datalake/mlflow/artifacts
  enabled: false
  fullnameOverride: ""
  global: {}
  image:
    pullPolicy: IfNotPresent
    repository: ayadi05/mlflow
    tag: 1.5.1
  ingress:
    annotations: {}
    enabled: false
    hosts:
    - mlflow.test
    path: /
    tls: []
  minio:
    accesskey: secret
    secretkey: secret
    url: minio.default.svc.cluster.local:9000
  nameOverride: ""
  nodeSelector: {}
  postgresql:
    audit:
      clientMinMessages: error
      logConnections: false
      logDisconnections: false
      logHostname: false
      logLinePrefix: ""
      logTimezone: ""
      pgAuditLog: ""
      pgAuditLogCatalog: "off"
    common:
      exampleValue: common-chart
      global:
        postgresql: {}
    commonAnnotations: {}
    containerSecurityContext:
      enabled: true
      runAsUser: 1001
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    extraDeploy: []
    extraEnv: []
    global:
      postgresql: {}
    image:
      debug: false
      pullPolicy: IfNotPresent
      registry: docker.io
      repository: bitnami/postgresql
      tag: 11.11.0-debian-10-r71
    ldap:
      baseDN: ""
      bind_password: null
      bindDN: ""
      enabled: false
      port: ""
      prefix: ""
      scheme: ""
      search_attr: ""
      search_filter: ""
      server: ""
      suffix: ""
      tls: {}
      url: ""
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    metrics:
      enabled: false
      extraEnvVars: {}
      image:
        pullPolicy: IfNotPresent
        registry: docker.io
        repository: bitnami/postgres-exporter
        tag: 0.9.0-debian-10-r43
      livenessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      prometheusRule:
        additionalLabels: {}
        enabled: false
        namespace: ""
        rules: []
      readinessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      securityContext:
        enabled: false
        runAsUser: 1001
      service:
        annotations:
          prometheus.io/port: "9187"
          prometheus.io/scrape: "true"
        loadBalancerIP: null
        type: ClusterIP
      serviceMonitor:
        additionalLabels: {}
        enabled: false
    networkPolicy:
      allowExternal: true
      enabled: false
      explicitNamespacesSelector: {}
    persistence:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      enabled: true
      mountPath: /bitnami/postgresql
      selector: {}
      size: 8Gi
      subPath: ""
    postgresqlDataDir: /bitnami/postgresql/data
    postgresqlDbUserConnectionLimit: null
    postgresqlMaxConnections: null
    postgresqlPghbaRemoveFilters: null
    postgresqlPostgresConnectionLimit: null
    postgresqlSharedPreloadLibraries: pgaudit
    postgresqlStatementTimeout: null
    postgresqlTcpKeepalivesCount: null
    postgresqlTcpKeepalivesIdle: null
    postgresqlTcpKeepalivesInterval: null
    postgresqlUsername: postgres
    primary:
      affinity: {}
      annotations: {}
      extraInitContainers: []
      extraVolumeMounts: []
      extraVolumes: []
      labels: {}
      nodeAffinityPreset:
        key: ""
        type: ""
        values: []
      nodeSelector: {}
      podAffinityPreset: ""
      podAnnotations: {}
      podAntiAffinityPreset: soft
      podLabels: {}
      priorityClassName: ""
      service: {}
      sidecars: []
      tolerations: []
    primaryAsStandBy:
      enabled: false
    psp:
      create: false
    rbac:
      create: false
    readReplicas:
      affinity: {}
      annotations: {}
      extraInitContainers: []
      extraVolumeMounts: []
      extraVolumes: []
      labels: {}
      nodeAffinityPreset:
        key: ""
        type: ""
        values: []
      nodeSelector: {}
      persistence:
        enabled: true
      podAffinityPreset: ""
      podAnnotations: {}
      podAntiAffinityPreset: soft
      podLabels: {}
      priorityClassName: ""
      resources: {}
      service: {}
      sidecars: []
      tolerations: []
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    replication:
      applicationName: my_application
      enabled: false
      numSynchronousReplicas: 0
      password: repl_password
      readReplicas: 1
      synchronousCommit: "off"
      user: repl_user
    resources:
      requests:
        cpu: 250m
        memory: 256Mi
    securityContext:
      enabled: true
      fsGroup: 1001
    service:
      annotations: {}
      port: 5432
      type: ClusterIP
    serviceAccount:
      enabled: false
    shmVolume:
      chmod:
        enabled: true
      enabled: true
    startupProbe:
      enabled: false
      failureThreshold: 10
      initialDelaySeconds: 30
      periodSeconds: 15
      successThreshold: 1
      timeoutSeconds: 5
    tls:
      certCAFilename: null
      certFilename: ""
      certKeyFilename: ""
      certificatesSecret: ""
      crlFilename: null
      enabled: false
      preferServerCiphers: true
    updateStrategy:
      type: RollingUpdate
    volumePermissions:
      enabled: false
      image:
        pullPolicy: Always
        registry: docker.io
        repository: bitnami/bitnami-shell
        tag: "10"
      securityContext:
        runAsUser: 0
  replicaCount: 1
  resources: {}
  service:
    annotations: {}
    port: 80
    type: NodePort
  tolerations: []
mongodb:
  affinity: {}
  annotations: {}
  arbiter:
    affinity: {}
    annotations: {}
    args: []
    command: []
    configuration: ""
    containerPorts:
      mongodb: 27017
    containerSecurityContext:
      enabled: true
      runAsNonRoot: true
      runAsUser: 1001
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    enabled: true
    existingConfigmap: ""
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraFlags: []
    extraVolumeMounts: []
    extraVolumes: []
    hostAliases: []
    initContainers: []
    labels: {}
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 20
      successThreshold: 1
      timeoutSeconds: 10
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    pdb:
      create: false
      maxUnavailable: ""
      minAvailable: 1
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podManagementPolicy: OrderedReady
    podSecurityContext:
      enabled: true
      fsGroup: 1001
      sysctls: []
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 20
      successThreshold: 1
      timeoutSeconds: 10
    resources:
      limits: {}
      requests: {}
    runtimeClassName: ""
    schedulerName: ""
    service:
      annotations: {}
      extraPorts: []
      nameOverride: ""
      ports:
        mongodb: 27017
    sidecars: []
    startupProbe:
      enabled: false
      failureThreshold: 30
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    terminationGracePeriodSeconds: ""
    tolerations: []
    topologySpreadConstraints: []
    updateStrategy:
      type: RollingUpdate
  architecture: standalone
  args: []
  auth:
    database: ""
    databases: []
    enabled: true
    existingSecret: ""
    password: ""
    passwords: []
    replicaSetKey: ""
    rootPassword: password1
    rootUser: root
    username: ""
    usernames: []
  clusterDomain: cluster.local
  command: []
  common:
    exampleValue: common-chart
    global:
      imagePullSecrets: []
      imageRegistry: ""
      namespaceOverride: ""
      storageClass: ""
  commonAnnotations: {}
  commonLabels: {}
  configuration: ""
  containerPorts:
    mongodb: 27017
  containerSecurityContext:
    enabled: true
    runAsNonRoot: true
    runAsUser: 1001
  customLivenessProbe: {}
  customReadinessProbe: {}
  customStartupProbe: {}
  diagnosticMode:
    args:
    - infinity
    command:
    - sleep
    enabled: false
  directoryPerDB: false
  disableJavascript: false
  disableSystemLog: false
  enableIPv6: false
  enableJournal: true
  enabled: false
  existingConfigmap: ""
  externalAccess:
    autoDiscovery:
      enabled: false
      image:
        digest: ""
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/kubectl
        tag: 1.25.2-debian-11-r2
      resources:
        limits: {}
        requests: {}
    enabled: false
    hidden:
      enabled: false
      service:
        annotations: {}
        domain: ""
        externalTrafficPolicy: Local
        extraPorts: []
        loadBalancerClass: ""
        loadBalancerIPs: []
        loadBalancerSourceRanges: []
        nodePorts: []
        portName: mongodb
        ports:
          mongodb: 27017
        sessionAffinity: None
        sessionAffinityConfig: {}
        type: LoadBalancer
    service:
      annotations: {}
      domain: ""
      externalTrafficPolicy: Local
      extraPorts: []
      loadBalancerClass: ""
      loadBalancerIPs: []
      loadBalancerSourceRanges: []
      nodePorts: []
      portName: mongodb
      ports:
        mongodb: 27017
      sessionAffinity: None
      sessionAffinityConfig: {}
      type: LoadBalancer
  extraDeploy: []
  extraEnvVars: []
  extraEnvVarsCM: ""
  extraEnvVarsSecret: ""
  extraFlags: []
  extraVolumeMounts: []
  extraVolumes: []
  fullnameOverride: ""
  global:
    imagePullSecrets: []
    imageRegistry: ""
    namespaceOverride: ""
    storageClass: ""
  hidden:
    affinity: {}
    annotations: {}
    args: []
    command: []
    configuration: ""
    containerPorts:
      mongodb: 27017
    containerSecurityContext:
      enabled: true
      runAsNonRoot: true
      runAsUser: 1001
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    enabled: false
    existingConfigmap: ""
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraFlags: []
    extraVolumeMounts: []
    extraVolumes: []
    hostAliases: []
    initContainers: []
    labels: {}
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 20
      successThreshold: 1
      timeoutSeconds: 10
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    pdb:
      create: false
      maxUnavailable: ""
      minAvailable: 1
    persistence:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      enabled: true
      medium: ""
      mountPath: /bitnami/mongodb
      size: 8Gi
      storageClass: ""
      subPath: ""
      volumeClaimTemplates:
        dataSource: {}
        requests: {}
        selector: {}
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podManagementPolicy: OrderedReady
    podSecurityContext:
      enabled: true
      fsGroup: 1001
      sysctls: []
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 20
      successThreshold: 1
      timeoutSeconds: 10
    replicaCount: 1
    resources:
      limits: {}
      requests: {}
    runtimeClassName: ""
    schedulerName: ""
    service:
      annotations: {}
      extraPorts: []
      portName: mongodb
      ports:
        mongodb: 27017
    sidecars: []
    startupProbe:
      enabled: false
      failureThreshold: 30
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    terminationGracePeriodSeconds: ""
    tolerations: []
    topologySpreadConstraints: []
    updateStrategy:
      type: RollingUpdate
  hostAliases: []
  image:
    debug: false
    digest: ""
    pullPolicy: IfNotPresent
    pullSecrets: []
    registry: docker.io
    repository: bitnami/mongodb
    tag: 6.0.2-debian-11-r1
  initContainers: []
  initdbScripts:
    create_admin_user.sh: |
      $MONGODB_BIN_DIR/mongo admin --host 127.0.0.1 --port $MONGODB_PORT_NUMBER -u root -p $MONGODB_ROOT_PASSWORD << EOF
      db.createUser({ user: "admin" , pwd: "password1", roles: ["userAdminAnyDatabase", "dbAdminAnyDatabase", "readWriteAnyDatabase"]})
      EOF
  initdbScriptsConfigMap: ""
  kubeVersion: ""
  labels: {}
  lifecycleHooks: {}
  livenessProbe:
    enabled: true
    failureThreshold: 6
    initialDelaySeconds: 30
    periodSeconds: 20
    successThreshold: 1
    timeoutSeconds: 10
  metrics:
    args: []
    command: []
    containerPort: 9216
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    enabled: false
    extraFlags: ""
    image:
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/mongodb-exporter
      tag: 0.34.0-debian-11-r19
    livenessProbe:
      enabled: true
      failureThreshold: 3
      initialDelaySeconds: 15
      periodSeconds: 5
      successThreshold: 1
      timeoutSeconds: 5
    password: ""
    prometheusRule:
      additionalLabels: {}
      enabled: false
      namespace: ""
      rules: []
    readinessProbe:
      enabled: true
      failureThreshold: 3
      initialDelaySeconds: 5
      periodSeconds: 5
      successThreshold: 1
      timeoutSeconds: 1
    resources:
      limits: {}
      requests: {}
    service:
      annotations:
        prometheus.io/path: /metrics
        prometheus.io/port: '{{ .Values.metrics.service.ports.metrics }}'
        prometheus.io/scrape: "true"
      extraPorts: []
      ports:
        metrics: 9216
      type: ClusterIP
    serviceMonitor:
      enabled: false
      honorLabels: false
      interval: 30s
      jobLabel: ""
      labels: {}
      metricRelabelings: []
      namespace: ""
      relabelings: []
      scrapeTimeout: ""
      selector: {}
    startupProbe:
      enabled: false
      failureThreshold: 30
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    username: ""
  nameOverride: ""
  namespaceOverride: ""
  nodeAffinityPreset:
    key: ""
    type: ""
    values: []
  nodeSelector: {}
  pdb:
    create: false
    maxUnavailable: ""
    minAvailable: 1
  persistence:
    accessModes:
    - ReadWriteOnce
    annotations: {}
    enabled: true
    existingClaim: ""
    medium: ""
    mountPath: /bitnami/mongodb
    resourcePolicy: ""
    size: 8Gi
    storageClass: ""
    subPath: ""
    volumeClaimTemplates:
      dataSource: {}
      requests: {}
      selector: {}
  podAffinityPreset: ""
  podAnnotations: {}
  podAntiAffinityPreset: soft
  podLabels: {}
  podManagementPolicy: OrderedReady
  podSecurityContext:
    enabled: true
    fsGroup: 1001
    sysctls: []
  podSecurityPolicy:
    allowPrivilegeEscalation: false
    create: false
    privileged: false
    spec: {}
  priorityClassName: ""
  rbac:
    create: false
    rules: []
  readinessProbe:
    enabled: true
    failureThreshold: 6
    initialDelaySeconds: 5
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 5
  replicaCount: 2
  replicaSetConfigurationSettings:
    configuration: {}
    enabled: false
  replicaSetHostnames: true
  replicaSetName: rs0
  resources:
    limits: {}
    requests: {}
  runtimeClassName: ""
  schedulerName: ""
  service:
    annotations: {}
    clusterIP: ""
    externalIPs: []
    externalTrafficPolicy: Local
    extraPorts: []
    loadBalancerClass: ""
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    nameOverride: ""
    nodePorts:
      mongodb: ""
    portName: mongodb
    ports:
      mongodb: 27017
    sessionAffinity: None
    sessionAffinityConfig: {}
    type: ClusterIP
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: true
    create: true
    name: ""
  sidecars: []
  startupProbe:
    enabled: false
    failureThreshold: 30
    initialDelaySeconds: 5
    periodSeconds: 20
    successThreshold: 1
    timeoutSeconds: 10
  systemLogVerbosity: 0
  terminationGracePeriodSeconds: ""
  tls:
    arbiter:
      existingSecret: ""
    autoGenerated: true
    caCert: ""
    caKey: ""
    enabled: false
    existingSecret: ""
    extraDnsNames: []
    hidden:
      existingSecrets: []
    image:
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/nginx
      tag: 1.23.1-debian-11-r26
    mode: requireTLS
    replicaset:
      existingSecrets: []
    resources:
      limits: {}
      requests: {}
    standalone:
      existingSecret: ""
  tolerations: []
  topologySpreadConstraints: []
  updateStrategy:
    type: RollingUpdate
  useStatefulSet: false
  volumePermissions:
    enabled: false
    image:
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/bitnami-shell
      tag: 11-debian-11-r37
    resources:
      limits: {}
      requests: {}
    securityContext:
      runAsUser: 0
nginx_ldapauth_proxy:
  enabled: false
  proxy:
    authName: admin
    host: fadi-kibana
    ldapBindDN: cn=admin,dc=ldap,dc=cetic,dc=be
    ldapDN: dc=ldap,dc=cetic,dc=be
    ldapFilter: objectClass=organizationalPerson
    ldapHost: fadi-openldap
    port: 443
    requires:
    - filter: cn=admin,dc=ldap,dc=cetic,dc=be
      name: admin
  secrets:
    ldapBindPassword: password1
  service:
    externalPort: 5601
    type: ClusterIP
nifi:
  affinity: {}
  auth:
    SSL:
      keystorePasswd: changeMe
      truststorePasswd: changeMe
    admin: CN=admin, OU=NIFI
    ldap:
      admin: cn=admin,dc=ldap,dc=example,dc=be
      authExpiration: 12 hours
      authStrategy: SIMPLE
      enabled: true
      host: ldap://fadi-openldap:389
      identityStrategy: USE_DN
      pass: Z2JHHezi4aAA
      searchBase: cn=admin,dc=ldap,dc=cetic,dc=be
      searchFilter: (objectClass=*)
      userIdentityAttribute: cn
    oidc:
      admin: <your_admin_email>
      claimIdentifyingUser: email
      clientId: <your_client_id>
      clientSecret: <your_client_secret>
      discoveryUrl: https://<your_keycloak_URL>/auth/realms/<your_realm>/.well-known/openid-configuration
      enabled: false
    singleUser:
      password: changemechangeme
      username: username
  ca:
    admin:
      cn: admin
    app_port: 9090
    enabled: false
    global: {}
    image:
      pullPolicy: IfNotPresent
      repository: apache/nifi-toolkit
      tag: 1.12.1
    openshift:
      scc:
        enabled: false
    persistence:
      accessModes:
      - ReadWriteOnce
      caStorage:
        size: 1Gi
      enabled: true
    replicaCount: 1
    resources:
      requests:
        cpu: "0.1"
        memory: 250Mi
    securityContext:
      fsGroup: 1000
      runAsUser: 1000
    server: ""
    service:
      port: 9090
      type: ClusterIP
    serviceAccount:
      create: false
    token: sixteenCharacters
  enabled: true
  env: []
  envFrom: []
  extraContainers: []
  extraVolumeMounts: []
  extraVolumes: []
  global: {}
  headless:
    annotations:
      service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
    type: ClusterIP
  image:
    pullPolicy: IfNotPresent
    repository: apache/nifi
    tag: 1.14.0
  ingress:
    annotations: {}
    enabled: false
    hosts: []
    path: /
    tls: []
  initContainers: {}
  jvmMemory: 2g
  logresources:
    limits:
      cpu: 50m
      memory: 50Mi
    requests:
      cpu: 10m
      memory: 10Mi
  metrics:
    prometheus:
      enabled: false
      port: 9092
      serviceMonitor:
        enabled: false
        labels: {}
  nifi-registry:
    affinity: {}
    extraEnvs: []
    flowProvider:
      git:
        config:
          data: ""
          enabled: false
          secretName: ""
        enabled: false
        remote: origin
      postgres:
        driverClass: org.postgresql.Driver
        driverURL: https://jdbc.postgresql.org/download/
        enabled: false
        fileName: postgresql-42.2.6.jar
        password: nifireg
        url: jdbc:postgresql://localhost/nifireg
        username: nifireg
    fullnameOverride: ""
    global: {}
    image:
      pullPolicy: IfNotPresent
      repository: apache/nifi-registry
      tag: 0.8.0
    imagePullSecrets: []
    ingress:
      annotations: {}
      enabled: false
      hosts:
      - host: chart-example.local
        paths: []
      tls: []
    initContainers:
      alpine:
        image: alpine
        tag: 3.6
      extraEnvs: []
      git:
        image: alpine/git
        tag: v2.26.2
    nameOverride: ""
    nodeSelector: {}
    persistence:
      database:
        accessMode: ReadWriteOnce
        size: 1Gi
      enabled: true
      flowStorage:
        accessMode: ReadWriteOnce
        size: 1Gi
    podAnnotations: {}
    podSecurityContext: {}
    replicaCount: 1
    resources: {}
    securityContext: {}
    service:
      port: 18080
      type: ClusterIP
    serviceAccount:
      annotations: {}
      create: true
      name: ""
    ssh:
      config: ""
      known_hosts: ""
    tests:
      images:
        busybox:
          image: busybox
          tag: 1.33.1
    tolerations: []
  nodeSelector: {}
  openldap:
    affinity: {}
    customLdifFiles:
      1-default-users.ldif: '# You can find an example ldif file at https://github.com/cetic/fadi/blob/master/examples/basic/example.ldif'
    enabled: false
    env:
      LDAP_BACKEND: hdb
      LDAP_REMOVE_CONFIG_AFTER_SETUP: "false"
      LDAP_TLS: "true"
      LDAP_TLS_ENFORCE: "false"
    existingSecret: ""
    extraLabels: {}
    global: {}
    image:
      pullPolicy: IfNotPresent
      repository: osixia/openldap
      tag: 1.2.4
    initResources: {}
    logLevel: info
    nodeSelector: {}
    persistence:
      accessMode: ReadWriteOnce
      enabled: true
      size: 8Gi
    podAnnotations: {}
    replicaCount: 1
    resources: {}
    service:
      annotations: {}
      externalIPs: []
      ldapPort: 389
      loadBalancerIP: ""
      loadBalancerSourceRanges: []
      sslLdapPort: 636
      type: ClusterIP
    strategy: {}
    test:
      enabled: false
      image:
        repository: dduportal/bats
        tag: 0.4.0
    tls:
      CA:
        enabled: false
        secret: ""
      enabled: false
      secret: ""
    tolerations: []
  openshift:
    route:
      enabled: false
    scc:
      enabled: false
  persistence:
    accessModes:
    - ReadWriteOnce
    authconfStorage:
      size: 100Mi
    configStorage:
      size: 100Mi
    contentRepoStorage:
      size: 10Gi
    dataStorage:
      size: 1Gi
    enabled: true
    flowfileRepoStorage:
      size: 10Gi
    logStorage:
      size: 5Gi
    provenanceRepoStorage:
      size: 10Gi
  postStart: /opt/nifi/psql; wget -P /opt/nifi/psql https://jdbc.postgresql.org/download/postgresql-42.2.6.jar
  properties:
    algorithm: NIFI_PBKDF2_AES_GCM_256
    clusterPort: 6007
    externalSecure: false
    httpsPort: 8443
    isNode: false
    provenanceStorage: 8 GB
    safetyValve:
      nifi.web.http.network.interface.default: eth0
      nifi.web.http.network.interface.lo: lo
    sensitiveKey: changeMechangeMe
    siteToSite:
      port: 10000
    webProxyHost: nifi.example.cetic.be
  registry:
    affinity: {}
    enabled: false
    extraEnvs: []
    flowProvider:
      git:
        config:
          data: ""
          enabled: false
          secretName: ""
        enabled: false
        remote: origin
      postgres:
        driverClass: org.postgresql.Driver
        driverURL: https://jdbc.postgresql.org/download/
        enabled: false
        fileName: postgresql-42.2.6.jar
        password: nifireg
        url: jdbc:postgresql://localhost/nifireg
        username: nifireg
    fullnameOverride: ""
    global: {}
    image:
      pullPolicy: IfNotPresent
      repository: apache/nifi-registry
      tag: 0.8.0
    imagePullSecrets: []
    ingress:
      annotations: {}
      enabled: false
      hosts:
      - host: chart-example.local
        paths: []
      tls: []
    initContainers:
      alpine:
        image: alpine
        tag: 3.6
      extraEnvs: []
      git:
        image: alpine/git
        tag: v2.26.2
    nameOverride: ""
    nodeSelector: {}
    persistence:
      database:
        accessMode: ReadWriteOnce
        size: 1Gi
      enabled: true
      flowStorage:
        accessMode: ReadWriteOnce
        size: 1Gi
    podAnnotations: {}
    podSecurityContext: {}
    port: 80
    replicaCount: 1
    resources: {}
    securityContext: {}
    service:
      port: 18080
      type: ClusterIP
    serviceAccount:
      annotations: {}
      create: true
      name: ""
    ssh:
      config: ""
      known_hosts: ""
    tests:
      images:
        busybox:
          image: busybox
          tag: 1.33.1
    tolerations: []
    url: ""
  replicaCount: 1
  resources: {}
  securityContext:
    fsGroup: 1000
    runAsUser: 1000
  service:
    annotations: {}
    httpsPort: 8443
    nodePort: ""
    processors:
      enabled: false
      ports:
      - name: processor01
        port: 7001
        targetPort: 7001
      - name: processor02
        port: 7002
        targetPort: 7002
    type: ClusterIP
  sidecar:
    image: busybox
    imagePullPolicy: IfNotPresent
    tag: 1.32.0
  sts:
    AntiAffinity: soft
    hostAliases: []
    pod:
      annotations:
        security.alpha.kubernetes.io/sysctls: net.ipv4.ip_local_port_range=10000 65000
    podManagementPolicy: Parallel
    serviceAccount:
      annotations: {}
      create: false
    startupProbe:
      enabled: false
      failureThreshold: 60
      periodSeconds: 10
  terminationGracePeriodSeconds: 30
  tolerations: []
  traefikIngress:
    enabled: true
    host: nifi.example.cetic.be
  zookeeper:
    affinity: {}
    allowAnonymousLogin: true
    auth:
      enabled: false
    autopurge:
      purgeInterval: 0
      snapRetainCount: 3
    clusterDomain: cluster.local
    commonAnnotations: {}
    commonLabels: {}
    dataLogDir: ""
    enabled: true
    fourlwCommandsWhitelist: srvr, mntr, ruok
    global: {}
    heapSize: 1024
    image:
      debug: false
      pullPolicy: IfNotPresent
      registry: docker.io
      repository: bitnami/zookeeper
      tag: 3.6.2-debian-10-r37
    initLimit: 10
    listenOnAllIPs: false
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      probeCommandTimeout: 2
      successThreshold: 1
      timeoutSeconds: 5
    logLevel: ERROR
    maxClientCnxns: 60
    maxSessionTimeout: 40000
    metrics:
      containerPort: 9141
      enabled: false
      prometheusRule:
        enabled: false
        rules: []
      service:
        annotations:
          prometheus.io/path: /metrics
          prometheus.io/port: '{{ .Values.metrics.service.port }}'
          prometheus.io/scrape: "true"
        port: 9141
        type: ClusterIP
      serviceMonitor:
        enabled: false
    networkPolicy:
      enabled: false
    nodeSelector: {}
    persistence:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      dataLogDir:
        size: 8Gi
      enabled: true
      size: 8Gi
    podAnnotations: {}
    podDisruptionBudget:
      maxUnavailable: 1
    podLabels: {}
    podManagementPolicy: Parallel
    port: 2181
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      probeCommandTimeout: 2
      successThreshold: 1
      timeoutSeconds: 5
    replicaCount: 3
    resources:
      requests:
        cpu: 250m
        memory: 256Mi
    securityContext:
      enabled: true
      fsGroup: 1001
      runAsUser: 1001
    service:
      annotations: {}
      electionPort: 3888
      followerPort: 2888
      headless:
        annotations: {}
      port: 2181
      publishNotReadyAddresses: true
      tls:
        client_enable: false
        client_keystore_password: ""
        client_keystore_path: /tls_key_store/key_store_file
        client_port: 3181
        client_truststore_password: ""
        client_truststore_path: /tls_trust_store/trust_store_file
        disable_base_client_port: false
        quorum_enable: false
        quorum_keystore_password: ""
        quorum_keystore_path: /tls_key_store/key_store_file
        quorum_truststore_password: ""
        quorum_truststore_path: /tls_trust_store/trust_store_file
      type: ClusterIP
    serviceAccount:
      create: false
    syncLimit: 5
    tickTime: 2000
    tolerations: []
    updateStrategy: RollingUpdate
    url: ""
    volumePermissions:
      enabled: false
      image:
        pullPolicy: Always
        registry: docker.io
        repository: bitnami/minideb
        tag: buster
      resources: {}
openldap:
  adminPassword: Z2JHHezi4aAA
  affinity: {}
  configPassword: password2
  customLdifFiles:
    1-default-users.ldif: '# You can find an example ldif file.'
  enabled: true
  env:
    LDAP_BACKEND: hdb
    LDAP_DOMAIN: ldap.cetic.be
    LDAP_ORGANISATION: Cetic
    LDAP_REMOVE_CONFIG_AFTER_SETUP: "false"
    LDAP_TLS: "true"
    LDAP_TLS_ENFORCE: "false"
    LDAP_TLS_VERIFY_CLIENT: try
  existingSecret: ""
  extraLabels: {}
  global: {}
  image:
    pullPolicy: IfNotPresent
    repository: osixia/openldap
    tag: 1.2.4
  initResources: {}
  logLevel: info
  nodeSelector: {}
  persistence:
    accessMode: ReadWriteOnce
    enabled: true
    size: 8Gi
  podAnnotations: {}
  replicaCount: 1
  resources: {}
  service:
    annotations: {}
    externalIPs: []
    ldapPort: 389
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    sslLdapPort: 636
    type: ClusterIP
  strategy: {}
  test:
    enabled: false
    image:
      repository: dduportal/bats
      tag: 0.4.0
  tls:
    CA:
      enabled: false
      secret: ""
    enabled: false
    secret: ""
  tolerations: []
phpldapadmin:
  affinity: {}
  enabled: true
  env:
    PHPLDAPADMIN_HTTPS: "false"
    PHPLDAPADMIN_LDAP_HOSTS: fadi-openldap
    PHPLDAPADMIN_TRUST_PROXY_SSL: "true"
  global: {}
  image:
    pullPolicy: IfNotPresent
    repository: osixia/phpldapadmin
    tag: 0.7.1
  ingress:
    annotations: {}
    enabled: false
    path: /
    tls: []
  livenessProbe:
    httpGet:
      path: /
      port: http
  nodeSelector: {}
  readinessProbe:
    httpGet:
      path: /
      port: http
  replicaCount: 1
  resources: {}
  service:
    annotations: {}
    port: 80
    type: ClusterIP
  tolerations: []
postgresql:
  enabled: true
  global: {}
  image:
    pullPolicy: IfNotPresent
    repository: postgres
    tag: "11.5"
  ldap:
    cron:
      mountPath: /workspace
      repo: ceticasbl/pg-ldap-sync
      restartPolicy: Never
      schedule: '*/30 * * * *'
      subPath: ""
      tag: latest
    enabled: true
    pgldapconfig: |-
      # Reference: https://github.com/larskanis/pg-ldap-sync/blob/master/config/sample-config.yaml
      # Connection parameters to LDAP server
      ldap_connection:
        host: fadi-openldap
        port: 389
        auth:
          method: :simple
          username: CN=admin,DC=ldap,DC=cetic,DC=be
          password: Z2JHHezi4aAA
        # Search parameters for LDAP users which should be synchronized
      ldap_users:
        base: CN=admin,DC=ldap,DC=cetic,DC=be
        # LDAP filter (according to RFC 2254)
        # defines to users in LDAP to be synchronized
        filter: (!(cn=admin))
        # this attribute is used as PG role name
        name_attribute: cn
        # lowercase name for use as PG role name
        lowercase_name: true
      ldap_groups:
          base: DC=ldap,DC=cetic,DC=be
          filter: (|(cn=group1)(cn=group2)(cn=group3))
          # this attribute is used as PG role name
          name_attribute: cn
          # this attribute must reference to all member DN's of the given group
          member_attribute: member
      # Connection parameters to PostgreSQL server
      # see also: http://rubydoc.info/gems/pg/PG/Connection#initialize-instance_method
      pg_connection:
        host: fadi-postgresql
        dbname: postgres # the db name is usually "postgres"
        user: admin # the user name is usually "postgres"
        password: Z2JHHezi4aAA # kubectl get secret --namespace fadi <pod_name> -o jsonpath="{.data.postgresql-password}" | base64 --decode
      pg_users:
        # Filter for identifying LDAP generated users in the database.
        # It's the WHERE-condition to "SELECT rolname, oid FROM pg_roles"
        # filter: rolcanlogin AND NOT rolsuper
        filter: oid IN (SELECT pam.member FROM pg_auth_members pam JOIN pg_roles pr ON pr.oid=pam.roleid WHERE pr.rolname='ldap_users')
        # Options for CREATE RULE statements
        create_options: LOGIN IN ROLE ldap_users
      pg_groups:
        # Filter for identifying LDAP generated groups in the database.
        # It's the WHERE-condition to "SELECT rolname, oid FROM pg_roles"
        # filter: NOT rolcanlogin AND NOT rolsuper
        filter: oid IN (SELECT pam.member FROM pg_auth_members pam JOIN pg_roles pr ON pr.oid=pam.roleid WHERE pr.rolname='ldap_groups')
        # Options for CREATE RULE statements
        create_options: NOLOGIN IN ROLE ldap_groups
        #grant_options:
  nodeSelector: {}
  persistence:
    accessModes:
    - ReadWriteOnce
    annotations: {}
    enabled: true
    mountPath: /var/lib/postgresql
    size: 10Gi
    subPath: ""
  postgresql:
    dataDir: /var/lib/postgresql/data/pgdata
    database: postgres
    initdbscripts: |-
      #!/bin/sh
      psql -c "create role ldap_users;" postgres admin
      psql -c "create role ldap_groups;" postgres admin
      psql -c "create database zabbix;" postgres admin
    password: Z2JHHezi4aAA
    pghba: |-
      local all all ldap ldapserver=fadi-openldap  ldapport=389 ldaptls=0 ldapbasedn="dc=ldap,dc=cetic,dc=be" ldapbinddn="cn=admin,dc=ldap,dc=cetic,dc=be" ldapbindpasswd=Z2JHHezi4aAA  ldapsearchfilter=cn=$username
      host all all 0.0.0.0/0  ldap ldapserver=fadi-openldap  ldapport=389 ldaptls=0 ldapbasedn="dc=ldap,dc=cetic,dc=be" ldapbinddn="cn=admin,dc=ldap,dc=cetic,dc=be" ldapbindpasswd=Z2JHHezi4aAA  ldapsearchfilter=cn=$username
    port: 5432
    username: admin
  resources: {}
  securityContext:
    enabled: true
    fsGroup: 1001
    runAsUser: 1001
  service:
    annotations: {}
    type: ClusterIP
  tolerations: []
  volumePermissions:
    enabled: true
    image:
      pullPolicy: Always
      registry: docker.io
      repository: debian
      tag: buster-slim
    securityContext:
      runAsUser: 0
rabbitmq:
  advancedConfiguration: ""
  affinity: {}
  args: []
  auth:
    erlangCookie: ""
    existingErlangSecret: ""
    existingPasswordSecret: ""
    password: password1
    securePassword: true
    tls:
      autoGenerated: false
      caCertificate: ""
      enabled: false
      existingSecret: ""
      existingSecretFullChain: false
      failIfNoPeerCert: true
      serverCertificate: ""
      serverKey: ""
      sslOptionsVerify: verify_peer
    username: admin
  clusterDomain: cluster.local
  clustering:
    addressType: hostname
    enabled: true
    forceBoot: false
    partitionHandling: autoheal
    rebalance: false
  command: []
  common:
    exampleValue: common-chart
    global:
      imagePullSecrets: []
      imageRegistry: ""
      storageClass: ""
  commonAnnotations: {}
  commonLabels: {}
  communityPlugins: ""
  configuration: |-
    ## Username and password
    ##
    default_user = {{ .Values.auth.username }}
    {{- if and (not .Values.auth.securePassword) .Values.auth.password }}
    default_pass = {{ .Values.auth.password }}
    {{- end }}
    {{- if .Values.clustering.enabled }}
    ## Clustering
    ##
    cluster_formation.peer_discovery_backend  = rabbit_peer_discovery_k8s
    cluster_formation.k8s.host = kubernetes.default
    cluster_formation.node_cleanup.interval = 10
    cluster_formation.node_cleanup.only_log_warning = true
    cluster_partition_handling = {{ .Values.clustering.partitionHandling }}
    {{- end }}
    {{- if .Values.loadDefinition.enabled }}
    load_definitions = {{ .Values.loadDefinition.file }}
    {{- end }}
    # queue master locator
    queue_master_locator = min-masters
    # enable guest user
    loopback_users.guest = false
    {{ tpl .Values.extraConfiguration . }}
    {{- if .Values.auth.tls.enabled }}
    ssl_options.verify = {{ .Values.auth.tls.sslOptionsVerify }}
    listeners.ssl.default = {{ .Values.service.ports.amqpTls }}
    ssl_options.fail_if_no_peer_cert = {{ .Values.auth.tls.failIfNoPeerCert }}
    ssl_options.cacertfile = /opt/bitnami/rabbitmq/certs/ca_certificate.pem
    ssl_options.certfile = /opt/bitnami/rabbitmq/certs/server_certificate.pem
    ssl_options.keyfile = /opt/bitnami/rabbitmq/certs/server_key.pem
    {{- end }}
    {{- if .Values.ldap.enabled }}
    auth_backends.1.authn = ldap
    auth_backends.1.authz = {{ ternary "ldap" "internal" .Values.ldap.authorisationEnabled }}
    auth_backends.2 = internal
    {{- $host :=  list }}
    {{- $port :=  ternary 636 389 .Values.ldap.tls.enabled }}
    {{- if .Values.ldap.uri }}
    {{- $hostPort := get (urlParse .Values.ldap.uri) "host" }}
    {{- $host = list (index (splitList ":" $hostPort) 0) -}}
    {{- if (contains ":" $hostPort) }}
    {{- $port = index (splitList ":" $hostPort) 1 -}}
    {{- end }}
    {{- end }}
    {{- range $index, $server := concat $host .Values.ldap.servers }}
    auth_ldap.servers.{{ add $index 1 }} = {{ $server }}
    {{- end }}
    auth_ldap.port = {{ coalesce .Values.ldap.port $port }}
    {{- if or .Values.ldap.user_dn_pattern .Values.ldap.userDnPattern }}
    auth_ldap.user_dn_pattern = {{ coalesce .Values.ldap.user_dn_pattern .Values.ldap.userDnPattern }}
    {{- end }}
    {{- if .Values.ldap.basedn }}
    auth_ldap.dn_lookup_base = {{ .Values.ldap.basedn }}
    {{- end }}
    {{- if .Values.ldap.uidField }}
    auth_ldap.dn_lookup_attribute = {{ .Values.ldap.uidField }}
    {{- end }}
    {{- if .Values.ldap.binddn }}
    auth_ldap.dn_lookup_bind.user_dn = {{ .Values.ldap.binddn }}
    auth_ldap.dn_lookup_bind.password = {{ required "'ldap.bindpw' is required when 'ldap.binddn' is defined" .Values.ldap.bindpw }}
    {{- end }}
    {{- if .Values.ldap.tls.enabled }}
    auth_ldap.use_ssl = {{ not .Values.ldap.tls.startTls }}
    auth_ldap.use_starttls = {{ .Values.ldap.tls.startTls }}
    {{- if .Values.ldap.tls.CAFilename }}
    auth_ldap.ssl_options.cacertfile = {{ .Values.ldap.tls.certificatesMountPath }}/{{ .Values.ldap.tls.CAFilename }}
    {{- end }}
    {{- if .Values.ldap.tls.certFilename }}
    auth_ldap.ssl_options.certfile = {{ .Values.ldap.tls.certificatesMountPath }}/{{ .Values.ldap.tls.certFilename }}
    auth_ldap.ssl_options.keyfile = {{ .Values.ldap.tls.certificatesMountPath }}/{{ required "'ldap.tls.certKeyFilename' is required when 'ldap.tls.certFilename' is defined" .Values.ldap.tls.certKeyFilename }}
    {{- end }}
    {{- if .Values.ldap.tls.skipVerify }}
    auth_ldap.ssl_options.verify = verify_none
    auth_ldap.ssl_options.fail_if_no_peer_cert = false
    {{- else if .Values.ldap.tls.verify }}
    auth_ldap.ssl_options.verify = {{ .Values.ldap.tls.verify }}
    {{- end }}
    {{- end }}
    {{- end }}
    {{- if .Values.metrics.enabled }}
    ## Prometheus metrics
    ##
    prometheus.tcp.port = 9419
    {{- end }}
    {{- if .Values.memoryHighWatermark.enabled }}
    ## Memory Threshold
    ##
    total_memory_available_override_value = {{ include "rabbitmq.toBytes" .Values.resources.limits.memory }}
    vm_memory_high_watermark.{{ .Values.memoryHighWatermark.type }} = {{ .Values.memoryHighWatermark.value }}
    {{- end }}
  containerPorts:
    amqp: 5672
    amqpTls: 5671
    dist: 25672
    epmd: 4369
    manager: 15672
    metrics: 9419
  containerSecurityContext:
    enabled: true
    runAsNonRoot: true
    runAsUser: 1001
  customLivenessProbe: {}
  customReadinessProbe: {}
  customStartupProbe: {}
  diagnosticMode:
    args:
    - infinity
    command:
    - sleep
    enabled: false
  dnsConfig: {}
  dnsPolicy: ""
  enabled: false
  extraConfiguration: |-
    #default_vhost = {{ .Release.Namespace }}-vhost
    #disk_free_limit.absolute = 50MB
  extraContainerPorts: []
  extraDeploy: []
  extraEnvVars: []
  extraEnvVarsCM: ""
  extraEnvVarsSecret: ""
  extraPlugins: rabbitmq_auth_backend_ldap
  extraSecrets: {}
  extraSecretsPrependReleaseName: false
  extraVolumeMounts: []
  extraVolumes: []
  fullnameOverride: ""
  global:
    imagePullSecrets: []
    imageRegistry: ""
    storageClass: ""
  hostAliases: []
  image:
    debug: false
    digest: ""
    pullPolicy: IfNotPresent
    pullSecrets: []
    registry: docker.io
    repository: bitnami/rabbitmq
    tag: 3.11.2-debian-11-r0
  ingress:
    annotations: {}
    enabled: false
    existingSecret: ""
    extraHosts: []
    extraPaths: []
    extraRules: []
    extraTls: []
    hostname: rabbitmq.local
    ingressClassName: ""
    path: /
    pathType: ImplementationSpecific
    secrets: []
    selfSigned: false
    tls: false
  initContainers: []
  initScripts: {}
  initScriptsCM: ""
  initScriptsSecret: ""
  kubeVersion: ""
  ldap:
    authorisationEnabled: false
    basedn: ""
    binddn: ""
    bindpw: ""
    enabled: false
    port: "389"
    servers: ldap-server
    tls:
      CAFilename: ""
      certFilename: ""
      certKeyFilename: ""
      certificatesMountPath: /opt/bitnami/rabbitmq/ldap/certs
      certificatesSecret: ""
      enabled: false
      skipVerify: false
      startTls: false
      verify: verify_peer
    uidField: ""
    uri: ""
    user_dn_pattern: cn=${username},dc=example,dc=org
    userDnPattern: ""
  lifecycleHooks: {}
  livenessProbe:
    enabled: true
    failureThreshold: 6
    initialDelaySeconds: 120
    periodSeconds: 30
    successThreshold: 1
    timeoutSeconds: 20
  loadDefinition:
    enabled: false
    existingSecret: ""
    file: /app/load_definition.json
  logs: '-'
  maxAvailableSchedulers: ""
  memoryHighWatermark:
    enabled: false
    type: relative
    value: 0.4
  metrics:
    enabled: false
    plugins: rabbitmq_prometheus
    podAnnotations:
      prometheus.io/port: '{{ .Values.service.ports.metrics }}'
      prometheus.io/scrape: "true"
    prometheusRule:
      additionalLabels: {}
      enabled: false
      namespace: ""
      rules: []
    serviceMonitor:
      annotations: {}
      enabled: false
      honorLabels: false
      interval: 30s
      jobLabel: ""
      labels: {}
      metricRelabelings: []
      namespace: ""
      path: ""
      podTargetLabels: {}
      relabelings: []
      scrapeTimeout: ""
      selector: {}
      targetLabels: {}
  nameOverride: ""
  namespaceOverride: ""
  networkPolicy:
    additionalRules: []
    allowExternal: true
    enabled: false
  nodeAffinityPreset:
    key: ""
    type: ""
    values: []
  nodeSelector: {}
  onlineSchedulers: ""
  pdb:
    create: false
    maxUnavailable: ""
    minAvailable: 1
  persistence:
    accessModes:
    - ReadWriteOnce
    annotations: {}
    enabled: true
    existingClaim: ""
    mountPath: /bitnami/rabbitmq/mnesia
    selector: {}
    size: 8Gi
    storageClass: ""
    subPath: ""
  plugins: rabbitmq_management rabbitmq_peer_discovery_k8s
  podAffinityPreset: ""
  podAnnotations: {}
  podAntiAffinityPreset: soft
  podLabels: {}
  podManagementPolicy: OrderedReady
  podSecurityContext:
    enabled: true
    fsGroup: 1001
  priorityClassName: ""
  rbac:
    create: true
  readinessProbe:
    enabled: true
    failureThreshold: 3
    initialDelaySeconds: 10
    periodSeconds: 30
    successThreshold: 1
    timeoutSeconds: 20
  replicaCount: 1
  resources:
    limits: {}
    requests: {}
  schedulerName: ""
  service:
    annotations: {}
    annotationsHeadless: {}
    clusterIP: ""
    distPortEnabled: true
    epmdPortEnabled: true
    externalIPs: []
    externalTrafficPolicy: Cluster
    extraPorts: []
    labels: {}
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    managerPortEnabled: true
    nodePorts:
      amqp: ""
      amqpTls: ""
      dist: ""
      epmd: ""
      manager: ""
      metrics: ""
    portEnabled: true
    portNames:
      amqp: amqp
      amqpTls: amqp-ssl
      dist: dist
      epmd: epmd
      manager: http-stats
      metrics: metrics
    ports:
      amqp: 5672
      amqpTls: 5671
      dist: 25672
      epmd: 4369
      manager: 15672
      metrics: 9419
    sessionAffinity: None
    sessionAffinityConfig: {}
    type: ClusterIP
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: true
    create: true
    name: ""
  sidecars: []
  startupProbe:
    enabled: false
    failureThreshold: 3
    initialDelaySeconds: 10
    periodSeconds: 30
    successThreshold: 1
    timeoutSeconds: 20
  statefulsetLabels: {}
  terminationGracePeriodSeconds: 120
  tolerations: []
  topologySpreadConstraints: []
  ulimitNofiles: "65536"
  updateStrategy:
    type: RollingUpdate
  volumePermissions:
    containerSecurityContext:
      runAsUser: 0
    enabled: false
    image:
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/bitnami-shell
      tag: 11-debian-11-r43
    resources:
      limits: {}
      requests: {}
seldon-core-operator:
  ambassador:
    enabled: true
    singleNamespace: false
  certManager:
    enabled: false
  controllerId: ""
  crd:
    create: true
  credentials:
    gcs:
      gcsCredentialFileName: gcloud-application-credentials.json
    s3:
      s3AccessKeyIDName: awsAccessKeyID
      s3SecretAccessKeyName: awsSecretAccessKey
  enabled: false
  engine:
    grpc:
      port: 5001
    image:
      pullPolicy: IfNotPresent
      registry: docker.io
      repository: seldonio/engine
      tag: 1.0.2
    logMessagesExternally: false
    port: 8000
    prometheus:
      path: prometheus
    securityContext:
      enabled: true
    serviceAccount:
      name: default
    user: 8888
  global: {}
  image:
    pullPolicy: IfNotPresent
    registry: docker.io
    repository: seldonio/seldon-core-operator
    tag: 1.0.2
  istio:
    enabled: false
    gateway: seldon-gateway
    tlsMode: ""
  kubeflow: false
  manager:
    cpuLimit: 500m
    cpuRequest: 100m
    memoryLimit: 300Mi
    memoryRequest: 200Mi
  predictiveUnit:
    port: 9000
  predictor_servers:
    MLFLOW_SERVER:
      grpc:
        defaultImageVersion: "0.2"
        image: seldonio/mlflowserver_grpc
      rest:
        defaultImageVersion: "0.2"
        image: seldonio/mlflowserver_rest
    SKLEARN_SERVER:
      grpc:
        defaultImageVersion: "0.2"
        image: seldonio/sklearnserver_grpc
      rest:
        defaultImageVersion: "0.2"
        image: seldonio/sklearnserver_rest
    TENSORFLOW_SERVER:
      grpc:
        defaultImageVersion: "0.7"
        image: seldonio/tfserving-proxy_grpc
      rest:
        defaultImageVersion: "0.7"
        image: seldonio/tfserving-proxy_rest
      tensorflow: true
      tfImage: tensorflow/serving:latest
    XGBOOST_SERVER:
      grpc:
        defaultImageVersion: "0.2"
        image: seldonio/xgboostserver_grpc
      rest:
        defaultImageVersion: "0.2"
        image: seldonio/xgboostserver_rest
  rbac:
    configmap:
      create: true
    create: true
  serviceAccount:
    create: true
    name: seldon-manager
  singleNamespace: false
  storageInitializer:
    cpuLimit: "1"
    cpuRequest: 100m
    image: gcr.io/kfserving/storage-initializer:0.2.1
    memoryLimit: 1Gi
    memoryRequest: 100Mi
  usageMetrics:
    enabled: false
  webhook:
    port: 443
spark:
  Master:
    Name: spark-master
  WebUi:
    Name: spark-webui
  Worker:
    Name: spark-worker
  Zeppelin:
    Name: spark-zeppelin
    Replicas: 0
  clusterDomain: cluster.local
  common:
    exampleValue: common-chart
    global:
      imagePullSecrets: []
      imageRegistry: ""
      storageClass: ""
  commonAnnotations: {}
  commonLabels: {}
  diagnosticMode:
    args:
    - infinity
    command:
    - sleep
    enabled: false
  enabled: true
  extraDeploy: []
  fullnameOverride: ""
  global:
    imagePullSecrets: []
    imageRegistry: ""
    storageClass: ""
  hostNetwork: false
  image:
    debug: false
    digest: ""
    pullPolicy: IfNotPresent
    pullSecrets: []
    registry: docker.io
    repository: bitnami/spark
    tag: 3.3.0-debian-11-r40
  ingress:
    annotations: {}
    apiVersion: ""
    enabled: false
    extraHosts: []
    extraPaths: []
    extraRules: []
    extraTls: []
    hostname: spark.local
    ingressClassName: ""
    path: /
    pathType: ImplementationSpecific
    secrets: []
    selfSigned: false
    tls: false
  initScripts: {}
  initScriptsCM: ""
  initScriptsSecret: ""
  kubeVersion: ""
  master:
    affinity: {}
    args: []
    command: []
    configOptions: ""
    containerPorts:
      cluster: 7077
      http: 8080
      https: 8480
    containerSecurityContext:
      enabled: true
      readOnlyRootFilesystem: false
      runAsNonRoot: true
      runAsUser: 1001
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    daemonMemoryLimit: ""
    existingConfigmap: ""
    extraContainerPorts: []
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraVolumeMounts: []
    extraVolumes: []
    hostAliases: []
    initContainers: []
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 180
      periodSeconds: 20
      successThreshold: 1
      timeoutSeconds: 5
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podSecurityContext:
      enabled: true
      fsGroup: 1001
      runAsGroup: 0
      runAsUser: 1001
      seLinuxOptions: {}
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    resources:
      limits: {}
      requests: {}
    schedulerName: ""
    sidecars: []
    startupProbe:
      enabled: false
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    terminationGracePeriodSeconds: ""
    tolerations: []
    topologySpreadConstraints: []
    updateStrategy:
      type: RollingUpdate
  metrics:
    enabled: false
    masterAnnotations:
      prometheus.io/path: /metrics/
      prometheus.io/port: '{{ .Values.master.containerPorts.http }}'
      prometheus.io/scrape: "true"
    podMonitor:
      additionalLabels: {}
      enabled: false
      extraMetricsEndpoints: []
      interval: 30s
      namespace: ""
      scrapeTimeout: ""
    prometheusRule:
      additionalLabels: {}
      enabled: false
      namespace: ""
      rules: []
    workerAnnotations:
      prometheus.io/path: /metrics/
      prometheus.io/port: '{{ .Values.worker.containerPorts.http }}'
      prometheus.io/scrape: "true"
  nameOverride: ""
  namespaceOverride: ""
  security:
    certificatesSecretName: ""
    passwordsSecretName: ""
    rpc:
      authenticationEnabled: false
      encryptionEnabled: false
    ssl:
      autoGenerated: false
      enabled: false
      existingSecret: ""
      keystorePassword: ""
      needClientAuth: false
      protocol: TLSv1.2
      resources:
        limits: {}
        requests: {}
      truststorePassword: ""
    storageEncryptionEnabled: false
  service:
    annotations: {}
    clusterIP: ""
    externalTrafficPolicy: Cluster
    extraPorts: []
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    nodePorts:
      cluster: ""
      http: ""
      https: ""
    ports:
      cluster: 7077
      http: 80
      https: 443
    sessionAffinity: None
    sessionAffinityConfig: {}
    type: ClusterIP
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: true
    create: true
    name: ""
  worker:
    affinity: {}
    args: []
    autoscaling:
      enabled: false
      maxReplicas: 5
      minReplicas: ""
      targetCPU: 50
      targetMemory: ""
    command: []
    configOptions: ""
    containerPorts:
      cluster: ""
      http: 8080
      https: 8480
    containerSecurityContext:
      enabled: true
      readOnlyRootFilesystem: false
      runAsNonRoot: true
      runAsUser: 1001
    coreLimit: ""
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    daemonMemoryLimit: ""
    dir: ""
    existingConfigmap: ""
    extraContainerPorts: []
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraVolumeMounts: []
    extraVolumes: []
    hostAliases: []
    initContainers: []
    javaOptions: ""
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 180
      periodSeconds: 20
      successThreshold: 1
      timeoutSeconds: 5
    memoryLimit: ""
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podManagementPolicy: OrderedReady
    podSecurityContext:
      enabled: true
      fsGroup: 1001
      runAsGroup: 0
      runAsUser: 1001
      seLinuxOptions: {}
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    replicaCount: 2
    resources:
      limits: {}
      requests: {}
    schedulerName: ""
    sidecars: []
    startupProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    terminationGracePeriodSeconds: ""
    tolerations: []
    topologySpreadConstraints: []
    updateStrategy:
      type: RollingUpdate
superset:
  affinity: {}
  configFile: |-
    from flask_appbuilder.security.manager import AUTH_DB,AUTH_LDAP
    #---------------------------------------------------------
    # Superset specific config
    #---------------------------------------------------------
    ROW_LIMIT = 5000
    SUPERSET_WORKERS = 2
    SUPERSET_WEBSERVER_PORT = 8088
    #---------------------------------------------------------
    #---------------------------------------------------------
    # Flask App Builder configuration
    #---------------------------------------------------------
    # Your App secret key
    SECRET_KEY = '\2\1thisismyscretkey\1\2\e\y\y\h'
    # The SQLAlchemy connection string to your database backend
    # This connection defines the path to the database that stores your
    # superset metadata (slices, connections, tables, dashboards, ...).
    # Note that the connection information to connect to the datasources
    # you want to explore are managed directly in the web UI
    SQLALCHEMY_DATABASE_URI = 'sqlite:////var/lib/superset/superset.db'
    # Flask-WTF flag for CSRF
    WTF_CSRF_ENABLED = True
    # Add endpoints that need to be exempt from CSRF protection
    WTF_CSRF_EXEMPT_LIST = []
    # Set this API key to enable Mapbox visualizations
    MAPBOX_API_KEY = ''
    DEBUG=True
    LOG_FORMAT = '%(asctime)s:%(levelname)s:%(name)s:%(message)s'
    LOG_LEVEL = 'DEBUG'
    AUTH_TYPE = AUTH_LDAP
    AUTH_LDAP_SERVER = "ldap://fadi-openldap:389"
    AUTH_LDAP_USE_TLS = False
    AUTH_USER_REGISTRATION = True
    AUTH_LDAP_SEARCH = "dc=ldap,dc=cetic,dc=be"
    AUTH_LDAP_BIND_USER = "cn=admin,dc=ldap,dc=cetic,dc=be"
    AUTH_LDAP_BIND_PASSWORD = "Z2JHHezi4aAA"
    AUTH_LDAP_UID_FIELD = "cn"
  deploymentAnnotations: {}
  enabled: true
  extraConfigFiles: {}
  extraEnv: {}
  extraEnvFromSecret: ""
  global: {}
  image:
    pullPolicy: IfNotPresent
    pullSecrets: []
    repository: amancevice/superset
    tag: 0.35.2
  ingress:
    annotations: {}
    enabled: false
    hosts:
    - superset.domain.com
    path: /
    tls: []
  initFile: |-
    /usr/local/bin/superset-init --username admin --firstname admin --lastname user --email admin@fab.org --password admin
    superset run
  livenessProbe:
    failureThreshold: 2
    httpGet:
      path: /health
      port: http
    initialDelaySeconds: 80
    periodSeconds: 10
    timeoutSeconds: 5
  nodeSelector: {}
  persistence:
    accessModes:
    - ReadWriteOnce
    enabled: true
    existingClaim: ""
    size: 8Gi
  readinessProbe:
    failureThreshold: 2
    httpGet:
      path: /health
      port: http
    initialDelaySeconds: 60
    periodSeconds: 10
    timeoutSeconds: 5
  replicaCount: 1
  resources: {}
  service:
    annotations: {}
    loadBalancerSourceRanges: []
    port: 9000
    type: ClusterIP
  tolerations: []
  traefikIngress:
    enabled: true
    host: superset.example.cetic.be
    tls: false
  worker:
    concurrency: 10
    enabled: false
    resources: {}
swaggerui:
  autoscaling:
    enabled: true
    maxReplicas: 10
    minReplicas: 1
    targetCPUUtilizationPercentage: 80
  deployment:
    extraEnv: null
    jsonNoCheckCertificate: false
    replicas: 1
  enabled: false
  global: {}
  image:
    pullPolicy: IfNotPresent
    repository: swaggerapi/swagger-ui
    tag: v3.24.3
  imagePullSecrets: []
  ingress:
    annotations: {}
    enabled: false
    hosts: []
    path: /
    tls: []
  livenessProbe:
    httpGet:
      path: /
      port: http
    initialDelaySeconds: 60
    periodSeconds: 30
    timeoutSeconds: 10
  resources: {}
  service:
    annotations: {}
    clusterIP: ""
    externalIPs: []
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    port: 8080
    type: NodePort
  swaggerui:
    jsonPath: ""
    jsonUrl: https://raw.githubusercontent.com/cetic/tsimulus-saas/master/oas/api-doc/openapi.json
    server:
      description: TSIMULUS API
      url: http://api-tsimulus.fadi.minikube
thingsboard:
  TB_RABBIT_MQ:
    TB_QUEUE_RABBIT_MQ_HOST: rabbitmq
    TB_QUEUE_RABBIT_MQ_PASSWORD: password1
    TB_QUEUE_RABBIT_MQ_PORT: 5672
    TB_QUEUE_RABBIT_MQ_USERNAME: admin
    TB_QUEUE_TYPE: rabbitmq
  affinity: {}
  autoscaling:
    enabled: false
    maxReplicas: 100
    minReplicas: 1
    targetCPUUtilizationPercentage: 80
  dataMount:
    enabled: false
    hostDir: /home/docker/data
    mountPath: /data
  enabled: false
  fullnameOverride: ""
  global: {}
  image:
    pullPolicy: IfNotPresent
    repository: thingsboard
    tag: tb-postgres
  imagePullSecrets: []
  ingress:
    annotations: {}
    enabled: false
    hosts:
    - host: thingsboard.test
    tls: []
  nameOverride: ""
  nodeSelector: {}
  podAnnotations: {}
  podSecurityContext: {}
  rabbitmq:
    advancedConfiguration: ""
    affinity: {}
    auth:
      erlangCookie: GDFSEKGZNSBRSEIFSRTNSFIKSEKLMEER
      password: password1
      tls:
        caCertificate: ""
        enabled: false
        existingSecretFullChain: false
        failIfNoPeerCert: true
        serverCertificate: ""
        serverKey: ""
        sslOptionsVerify: verify_peer
      username: admin
    clusterDomain: cluster.local
    clustering:
      addressType: hostname
      enabled: true
      forceBoot: false
      rebalance: false
    common:
      exampleValue: common-chart
      global: {}
    configuration: |-
      {{- if not .Values.loadDefinition.enabled -}}
      ## Username and password
      ##
      default_user = {{ .Values.auth.username }}
      default_pass = CHANGEME
      {{- end }}
      {{- if .Values.clustering.enabled }}
      ## Clustering
      ##
      cluster_formation.peer_discovery_backend  = rabbit_peer_discovery_k8s
      cluster_formation.k8s.host = kubernetes.default.svc.{{ .Values.clusterDomain }}
      cluster_formation.node_cleanup.interval = 10
      cluster_formation.node_cleanup.only_log_warning = true
      cluster_partition_handling = autoheal
      {{- end }}
      # queue master locator
      queue_master_locator = min-masters
      # enable guest user
      loopback_users.guest = false
      {{ tpl .Values.extraConfiguration . }}
      {{- if .Values.auth.tls.enabled }}
      ssl_options.verify = {{ .Values.auth.tls.sslOptionsVerify }}
      listeners.ssl.default = {{ .Values.service.tlsPort }}
      ssl_options.fail_if_no_peer_cert = {{ .Values.auth.tls.failIfNoPeerCert }}
      ssl_options.cacertfile = /opt/bitnami/rabbitmq/certs/ca_certificate.pem
      ssl_options.certfile = /opt/bitnami/rabbitmq/certs/server_certificate.pem
      ssl_options.keyfile = /opt/bitnami/rabbitmq/certs/server_key.pem
      {{- end }}
      {{- if .Values.ldap.enabled }}
      auth_backends.1 = rabbit_auth_backend_ldap
      auth_backends.2 = internal
      {{- range $index, $server := .Values.ldap.servers }}
      auth_ldap.servers.{{ add $index 1 }} = {{ $server }}
      {{- end }}
      auth_ldap.port = {{ .Values.ldap.port }}
      auth_ldap.user_dn_pattern = {{ .Values.ldap.user_dn_pattern  }}
      {{- if .Values.ldap.tls.enabled }}
      auth_ldap.use_ssl = true
      {{- end }}
      {{- end }}
      {{- if .Values.metrics.enabled }}
      ## Prometheus metrics
      ##
      prometheus.tcp.port = 9419
      {{- end }}
      {{- if .Values.memoryHighWatermark.enabled }}
      ## Memory Threshold
      ##
      total_memory_available_override_value = {{ include "rabbitmq.toBytes" .Values.resources.limits.memory }}
      vm_memory_high_watermark.{{ .Values.memoryHighWatermark.type }} = {{ .Values.memoryHighWatermark.value }}
      {{- end }}
    containerSecurityContext: {}
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    enabled: false
    extraConfiguration: |-
      #default_vhost = {{ .Release.Namespace }}-vhost
      #disk_free_limit.absolute = 50MB
      #load_definitions = /app/load_definition.json
    extraContainerPorts: []
    extraEnvVars: []
    extraPlugins: rabbitmq_auth_backend_ldap
    extraSecrets: {}
    extraSecretsPrependReleaseName: false
    extraVolumeMounts: []
    extraVolumes: []
    global: {}
    hostAliases: []
    image:
      debug: false
      pullPolicy: IfNotPresent
      registry: docker.io
      repository: bitnami/rabbitmq
      tag: 3.8.14-debian-10-r24
    ingress:
      annotations: {}
      certManager: false
      enabled: false
      hostname: rancher.test
      path: /
      pathType: ImplementationSpecific
      secrets: []
      tls: false
    initContainers: {}
    kubeVersion: null
    ldap:
      enabled: false
      port: "389"
      servers: ldap-server
      tls:
        enabled: false
      user_dn_pattern: cn=${username},dc=example,dc=org
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 120
      periodSeconds: 30
      successThreshold: 1
      timeoutSeconds: 20
    loadDefinition:
      enabled: false
    logs: '-'
    memoryHighWatermark:
      enabled: false
      type: relative
      value: 0.4
    metrics:
      enabled: false
      plugins: rabbitmq_prometheus
      podAnnotations:
        prometheus.io/port: '{{ .Values.service.metricsPort }}'
        prometheus.io/scrape: "true"
      prometheusRule:
        additionalLabels: {}
        enabled: false
        namespace: ""
        rules: []
      serviceMonitor:
        additionalLabels: {}
        enabled: false
        honorLabels: false
        interval: 30s
    networkPolicy:
      allowExternal: true
      enabled: false
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    pdb:
      create: false
      minAvailable: 1
    persistence:
      accessMode: ReadWriteOnce
      enabled: true
      selector: {}
      size: 8Gi
      volumes: null
    plugins: rabbitmq_management rabbitmq_peer_discovery_k8s
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podManagementPolicy: OrderedReady
    podSecurityContext:
      enabled: true
      fsGroup: 1001
      runAsUser: 1001
    priorityClassName: ""
    rbac:
      create: true
    readinessProbe:
      enabled: true
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 30
      successThreshold: 1
      timeoutSeconds: 20
    replicaCount: 1
    resources:
      limits: {}
      requests: {}
    service:
      annotations: {}
      annotationsHeadless: {}
      distPort: 25672
      distPortName: dist
      epmdPortName: epmd
      externalTrafficPolicy: Cluster
      extraPorts: []
      labels: {}
      managerPort: 15672
      managerPortEnabled: true
      managerPortName: http-stats
      metricsPort: 9419
      metricsPortName: metrics
      port: 5672
      portName: amqp
      tlsPort: 5671
      tlsPortName: amqp-ssl
      type: NodePort
    serviceAccount:
      create: true
    sidecars: {}
    statefulsetLabels: {}
    terminationGracePeriodSeconds: 120
    tolerations: []
    topologySpreadConstraints: {}
    ulimitNofiles: "65536"
    updateStrategyType: RollingUpdate
    volumePermissions:
      enabled: false
      image:
        pullPolicy: Always
        pullSecrets: []
        registry: docker.io
        repository: bitnami/bitnami-shell
        tag: "10"
      resources:
        limits: {}
        requests: {}
  readinessProbe:
    enabled: true
    initialDelaySeconds: 60
    periodSeconds: 7
  replicaCount: 1
  resources: {}
  securityContext: {}
  service:
    port: 8080
    type: NodePort
  serviceAccount:
    annotations: {}
    create: false
    name: ""
  tolerations: []
traefik:
  additionalArguments:
  - --providers.kubernetesIngress.ingressClass=traefik-cert-manager
  additionalVolumeMounts: []
  affinity: {}
  autoscaling:
    enabled: false
  dashboardHost: <your_dashboard_domain_name>
  dashboardIngress:
    enabled: false
  deployment:
    additionalContainers: []
    additionalVolumes: []
    annotations: {}
    enabled: true
    imagePullSecrets: []
    initContainers: []
    kind: Deployment
    labels: {}
    podAnnotations: {}
    podLabels: {}
    replicas: 1
    terminationGracePeriodSeconds: 60
  enabled: true
  env: []
  envFrom: []
  experimental:
    kubernetesGateway:
      appLabelSelector: traefik
      certificates: []
      enabled: false
    plugins:
      enabled: false
  global: {}
  globalArguments:
  - --global.checknewversion
  - --global.sendanonymoususage
  hostNetwork: false
  image:
    name: traefik
    pullPolicy: IfNotPresent
    tag: ""
  ingressClass:
    enabled: false
    fallbackApiVersion: ""
    isDefaultClass: false
  ingressRoute:
    dashboard:
      annotations: {}
      enabled: true
      labels: {}
  logs:
    access:
      enabled: false
      fields:
        general:
          defaultmode: keep
          names: {}
        headers:
          defaultmode: drop
          names: {}
      filters: {}
    general:
      level: ERROR
  metrics:
    prometheus:
      entryPoint: metrics
  nodeSelector: {}
  persistence:
    accessMode: ReadWriteOnce
    annotations: {}
    enabled: false
    name: data
    path: /data
    size: 128Mi
  pilot:
    enabled: false
    token: ""
  podDisruptionBudget:
    enabled: false
  podSecurityContext:
    fsGroup: 65532
  podSecurityPolicy:
    enabled: false
  ports:
    metrics:
      expose: false
      exposedPort: 9100
      port: 9100
      protocol: TCP
    traefik:
      expose: false
      exposedPort: 9000
      port: 9000
      protocol: TCP
    web:
      expose: true
      exposedPort: 80
      port: 8000
      protocol: TCP
    websecure:
      expose: true
      exposedPort: 443
      port: 8443
      protocol: TCP
      tls:
        certResolver: ""
        domains: []
        enabled: false
        options: ""
  priorityClassName: ""
  providers:
    kubernetesCRD:
      allowCrossNamespace: false
      allowExternalNameServices: false
      enabled: true
      namespaces: []
    kubernetesIngress:
      enabled: true
      namespaces: []
      publishedService:
        enabled: false
  rbac:
    enabled: true
    namespaced: false
  resources: {}
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 1
  securityContext:
    capabilities:
      drop:
      - ALL
    readOnlyRootFilesystem: true
    runAsGroup: 65532
    runAsNonRoot: true
    runAsUser: 65532
  service:
    annotations: {}
    annotationsTCP: {}
    annotationsUDP: {}
    enabled: true
    externalIPs: []
    labels: {}
    loadBalancerSourceRanges: []
    spec:
      loadBalancerIP: null
    type: LoadBalancer
  serviceAccount:
    name: ""
  serviceAccountAnnotations: {}
  tlsOptions: {}
  tolerations: []
  volumes: []
tsaas:
  enabled: false
  env:
    binding:
      value: 0.0.0.0
  fullnameOverride: ""
  global: {}
  image:
    pullPolicy: IfNotPresent
    repository: ceticasbl/tsimulus-saas
    tag: 0.1.18
  ingress:
    annotations: {}
    enabled: false
    hosts: []
    path: /
    tls: []
  nameOverride: ""
  replicaCount: 1
  resources:
    limits:
      cpu: 500m
      memory: 1000Mi
    requests:
      cpu: 250m
      memory: 250Mi
  service:
    port: 8080
    type: NodePort
zabbix:
  affinity: {}
  enabled: false
  global: {}
  ingress:
    annotations: {}
    enabled: false
    hosts:
    - host: null
      paths: []
    tls: []
  livenessProbe:
    failureThreshold: 6
    initialDelaySeconds: 30
    path: /
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 5
  nodeSelector: {}
  postgresql:
    audit:
      clientMinMessages: error
      logConnections: false
      logDisconnections: false
      logHostname: false
      logLinePrefix: ""
      logTimezone: ""
      pgAuditLog: ""
      pgAuditLogCatalog: "off"
    common:
      exampleValue: common-chart
      global:
        postgresql: {}
    commonAnnotations: {}
    containerSecurityContext:
      enabled: true
      runAsUser: 1001
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    enabled: false
    extraDeploy: []
    extraEnv: []
    global:
      postgresql: {}
    image:
      debug: false
      pullPolicy: IfNotPresent
      registry: docker.io
      repository: bitnami/postgresql
      tag: 11.11.0-debian-10-r71
    ldap:
      baseDN: ""
      bind_password: null
      bindDN: ""
      enabled: false
      port: ""
      prefix: ""
      scheme: ""
      search_attr: ""
      search_filter: ""
      server: ""
      suffix: ""
      tls: {}
      url: ""
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    metrics:
      enabled: false
      extraEnvVars: {}
      image:
        pullPolicy: IfNotPresent
        registry: docker.io
        repository: bitnami/postgres-exporter
        tag: 0.9.0-debian-10-r43
      livenessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      prometheusRule:
        additionalLabels: {}
        enabled: false
        namespace: ""
        rules: []
      readinessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      securityContext:
        enabled: false
        runAsUser: 1001
      service:
        annotations:
          prometheus.io/port: "9187"
          prometheus.io/scrape: "true"
        loadBalancerIP: null
        type: ClusterIP
      serviceMonitor:
        additionalLabels: {}
        enabled: false
    networkPolicy:
      allowExternal: true
      enabled: false
      explicitNamespacesSelector: {}
    persistence:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      enabled: true
      mountPath: /bitnami/postgresql
      selector: {}
      size: 8Gi
      subPath: ""
    postgresqlDataDir: /bitnami/postgresql/data
    postgresqlDatabase: zabbix
    postgresqlDbUserConnectionLimit: null
    postgresqlMaxConnections: null
    postgresqlPassword: zabbix_pwd
    postgresqlPghbaRemoveFilters: null
    postgresqlPostgresConnectionLimit: null
    postgresqlPostgresPassword: zabbix_pwd
    postgresqlSharedPreloadLibraries: pgaudit
    postgresqlStatementTimeout: null
    postgresqlTcpKeepalivesCount: null
    postgresqlTcpKeepalivesIdle: null
    postgresqlTcpKeepalivesInterval: null
    postgresqlUsername: zabbix
    primary:
      affinity: {}
      annotations: {}
      extraInitContainers: []
      extraVolumeMounts: []
      extraVolumes: []
      labels: {}
      nodeAffinityPreset:
        key: ""
        type: ""
        values: []
      nodeSelector: {}
      podAffinityPreset: ""
      podAnnotations: {}
      podAntiAffinityPreset: soft
      podLabels: {}
      priorityClassName: ""
      service: {}
      sidecars: []
      tolerations: []
    primaryAsStandBy:
      enabled: false
    psp:
      create: false
    rbac:
      create: false
    readReplicas:
      affinity: {}
      annotations: {}
      extraInitContainers: []
      extraVolumeMounts: []
      extraVolumes: []
      labels: {}
      nodeAffinityPreset:
        key: ""
        type: ""
        values: []
      nodeSelector: {}
      persistence:
        enabled: true
      podAffinityPreset: ""
      podAnnotations: {}
      podAntiAffinityPreset: soft
      podLabels: {}
      priorityClassName: ""
      resources: {}
      service: {}
      sidecars: []
      tolerations: []
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    replication:
      applicationName: my_application
      enabled: false
      numSynchronousReplicas: 0
      password: repl_password
      readReplicas: 1
      synchronousCommit: "off"
      user: repl_user
    resources:
      requests:
        cpu: 250m
        memory: 256Mi
    securityContext:
      enabled: true
      fsGroup: 1001
    service:
      annotations: {}
      port: 5432
      type: ClusterIP
    serviceAccount:
      enabled: false
    shmVolume:
      chmod:
        enabled: true
      enabled: true
    startupProbe:
      enabled: false
      failureThreshold: 10
      initialDelaySeconds: 30
      periodSeconds: 15
      successThreshold: 1
      timeoutSeconds: 5
    tls:
      certCAFilename: null
      certFilename: ""
      certKeyFilename: ""
      certificatesSecret: ""
      crlFilename: null
      enabled: false
      preferServerCiphers: true
    updateStrategy:
      type: RollingUpdate
    volumePermissions:
      enabled: false
      image:
        pullPolicy: Always
        registry: docker.io
        repository: bitnami/bitnami-shell
        tag: "10"
      securityContext:
        runAsUser: 0
  readinessProbe:
    failureThreshold: 6
    initialDelaySeconds: 5
    path: /
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 5
  tolerations: []
  zabbixServer:
    DB_SERVER_HOST: fadi-postgresql
    POSTGRES_DB: zabbix
    POSTGRES_PASSWORD: password1
    POSTGRES_USER: admin
    hostIP: 0.0.0.0
    hostPort: false
    image:
      pullPolicy: IfNotPresent
      pullSecrets: []
      repository: zabbix/zabbix-server-pgsql
      tag: ubuntu-5.4.1
    replicaCount: 1
    resources: {}
    service:
      port: 10051
      type: ClusterIP
  zabbixagent:
    ZBX_ACTIVE_ALLOW: true
    ZBX_HOSTNAME: zabbix-agent
    ZBX_JAVAGATEWAY_ENABLE: false
    ZBX_PASSIVE_ALLOW: true
    ZBX_PASSIVESERVERS: 127.0.0.1
    ZBX_SERVER_HOST: 127.0.01
    ZBX_SERVER_PORT: 10051
    ZBX_VMWARECACHESIZE: 128M
    enabled: true
    image:
      pullPolicy: IfNotPresent
      pullSecrets: []
      repository: zabbix/zabbix-agent
      tag: ubuntu-5.4.1
    resources: {}
    service:
      port: 10050
      targetPort: 10050
      type: ClusterIP
  zabbixproxy:
    DB_SERVER_HOST: maria-mariadb
    DB_SERVER_PORT: 3306
    MYSQL_DATABASE: my_database
    MYSQL_PASSWORD: password1
    MYSQL_USER: admin
    ZBX_HOSTNAME: zabbix-proxy
    ZBX_JAVAGATEWAY_ENABLE: false
    ZBX_PROXYMODE: 0
    ZBX_SERVER_HOST: zabbix-server
    ZBX_SERVER_PORT: 10051
    ZBX_VMWARECACHESIZE: 128M
    enabled: false
    image:
      pullPolicy: IfNotPresent
      pullSecrets: []
      repository: zabbix/zabbix-proxy-mysql
      tag: ubuntu-5.4.1
    resources: {}
    service:
      port: 10051
      targetPort: 10051
      type: ClusterIP
  zabbixweb:
    DB_SERVER_HOST: fadi-postgresql
    DB_SERVER_PORT: 5432
    POSTGRES_DB: zabbix
    POSTGRES_PASSWORD: password1
    POSTGRES_USER: admin
    ZBX_SERVER_HOST: zabbix-server
    ZBX_SERVER_PORT: 10051
    enabled: true
    image:
      pullPolicy: IfNotPresent
      pullSecrets: []
      repository: zabbix/zabbix-web-apache-pgsql
      tag: ubuntu-5.4.1
    service:
      port: 80
      targetPort: 8080
      type: NodePort
